[["Map",1,2,9,10,23,24,81,82,173,174,193,194],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.10.2","content-config-digest","6cbba14609b0bbbf","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"prefetch\":true,\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"mermaid\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{\"light\":\"github-light\",\"dark\":\"catppuccin-frappe\"},\"wrap\":false,\"transformers\":[{\"name\":\"@shikijs/transformers:notation-diff\"},{\"name\":\"@shikijs/transformers:notation-highlight\"},{\"name\":\"@shikijs/transformers:notation-highlight-word\"},{\"name\":\"@shikijs/transformers:notation-focus\"},{\"name\":\"@shikijs/transformers:notation-error-level\"},{\"name\":\"@shikijs/transformers:meta-highlight\"}]},\"remarkPlugins\":[null,null],\"rehypePlugins\":[null,[null,{\"customClassNames\":{\"calloutClass\":\"callout\",\"calloutTitleClass\":\"callout-title\",\"calloutContentClass\":\"callout-content\"}}],null,null],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12],"welcome",{"id":11,"data":13,"body":19,"filePath":20,"digest":21,"deferredRender":22},{"title":14,"description":15,"permalink":11,"authors":16,"publishedAt":18},"Discover Explainer","Discover Explainer is a tool that helps you create beautiful, responsive, and accessible web documentation using Astro. It's built with Astro, Tailwind CSS, and TypeScript.",[17],"leadcode_dev","2024-01-01:23:00:00","# Welcome to Explainer\n\nExplainer is a documentation boilerplate designed to help you create beautiful, responsive, and accessible web documentation using [Astro](https://astro.build). This project combines the power of Astro with [Tailwind CSS](https://tailwindcss.com) and [TypeScript](https://www.typescriptlang.org) to provide a smooth development experience.\n\n## Why Explainer?\n\nDocumentation is often overlooked, but it's essential for the adoption and effective use of your project.\nExplainer fills an important gap in the technical documentation ecosystem. While Vue has robust solutions like Vitepress, the React ecosystem suffers from a lack of alternatives that don't depend on Next.js. Most documentation frameworks for React are closely tied to Next.js, which can be limiting for many projects.\n\nThis is where Astro, and by extension Explainer, particularly shines. Astro offers remarkable flexibility by allowing you to integrate any technological component related to your business. You can easily incorporate React, Vue, Svelte components, or even standard web elements according to your specific needs.\n\nThis agnostic approach allows you to create documentation that perfectly aligns with your existing technology stack, without forcing you to adopt a particular ecosystem. Whether you work with React, Vue, or other frameworks, Explainer adapts to your needs rather than the other way around.","src/content/blog/welcome.mdx","f5b3166b4e8226c4",true,"guide",["Map",25,26,35,36,44,45,53,54,63,64,72,73],"commands",{"id":25,"data":27,"body":32,"filePath":33,"digest":34,"deferredRender":22},{"title":28,"description":29,"permalink":25,"order":30,"icon":31},"Commands","Lorem ipsum dolor sit amet, consectetur adipiscing elit.",5,"lucide:square-slash","# Commands\n\nSlash commands were implemented with the aim of replacing messages considered as commands with a start-of-line\ncharacter, often defined as a message prefix like `!`.\n\n> [!important]\n> Please see the dedicated [section](/docs/api/commands) for more information.\n\n---\n\n## Introduction\n\nThe Discord API allows users to interact with bots in a more intuitive and structured way, using predefined syntax to make it easier to execute specific commands without having to remember prefixes or complex message formats.\n\nThey were created to replace message-based commands with prefixes, making the user experience smoother and reducing\nsyntax errors.\n\n> [!note]\n> When you change the structure of your commands, please restart your entire application process so that the changes take\n> effect even if the `hmr` is active.\n\n## Builder approach\n\nFrom the `Client`, we can chain commands listeners using the following pattern :\n\n:::code-group labels=[main.dart]\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.commands.declare((command) {\n    command\n      ..setName('foo')\n      ..setDescription('This is a command description')\n      ..setHandler((ctx) => ctx.interaction.reply('Hello, world!'));\n  });\n\n  await client.init();\n}\n```\n:::\n\n---\n\n## Object-oriented approach\n\nFor benchmarking purposes, we recommend using the `functional` approach, but when developing applications requiring \nmore than 2 events or commands, we recommend using the object-oriented approach.\n\n:::code-group labels=[command.dart, main.dart]\n```dart\nfinal class MyCommand implements CommandDeclaration {\n  void handle(CommandContext ctx) {\n    print('Hello, world!');\n  }\n  \n  @override\n  CommandDeclarationBuilder build() {\n    return CommandDeclarationBuilder()\n      ..setName('foo')\n      ..setDescription('This is a command description')\n      ..setHandler(handle);\n  }\n}\n```\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.register(MyCommand.new);\n\n  await client.init();\n}\n```\n:::","src/content/docs/guide/commands.mdx","b542a1f4b712e287","environment-variables",{"id":35,"data":37,"body":41,"filePath":42,"digest":43,"deferredRender":22},{"title":38,"description":29,"permalink":35,"order":39,"icon":40},"Environment variables",3,"lucide:key-round","# Environment variables\n\nEnvironment variables serve the purpose of storing secrets like the database password, the app secret, or an API key outside of your application codebase.\n\nIn addition, environment variables can be used to obtain different configurations depending on the environment, such as the use of a secret to use an API or database identifiers.\n\n> [!note]\n> Please read the full documentation of the environment in the dedicated [section](/docs/api/environment-variables).\n\n---\n\nWe're providing an `Environment` class to access the various environment variables in your application.\n\n:::code-group labels=[.env, schema.dart]\n```dotenv\nDART_ENV=development\nTOKEN=your_token\nDISCORD_REST_API_VERSION=10\nDISCORD_WS_VERSION=10\nINTENT=3276799\nLOG_LEVEL=TRACE\n```\n```dart\nfinal class AppEnv implements DefineEnvironment {\n  static final String dartEnv = 'DART_ENV';\n  static final String token = 'TOKEN';\n  static final String discordRestHttpVersion = 'DISCORD_REST_API_VERSION';\n  static final String discordWssVersion = 'DISCORD_WS_VERSION';\n  static final String intent = 'INTENT';\n  static final String logLevel = 'LOG_LEVEL';\n\n  @override\n  final Map\u003CString, EnvSchema> schema = {\n    dartEnv: env.enumerable(DartEnv.values),\n    token: env.string(),\n    discordRestHttpVersion: env.number(),\n    discordWssVersion: env.number(),\n    intent: env.number(),\n    logLevel: env.enumerable(LogLevel.values),\n  };\n}\n\nenum DartEnv implements Enumerable\u003CString> {\n  development('development'),\n  production('production');\n\n  @override\n  final String value;\n\n  const DartEnv(this.value);\n}\n```\n:::","src/content/docs/guide/environment-variables.mdx","d34329e4188f5426","deployment",{"id":44,"data":46,"body":50,"filePath":51,"digest":52,"deferredRender":22},{"title":47,"description":29,"permalink":44,"order":48,"icon":49},"Deployment",6,"lucide:rocket","# Deployment\n\nDeployment is an extremely important part of the process, but one that most developers dread because it falls outside the developer's core business and into that of devops.\n\n> [!important]\n> We recommend deploying via a docker system, see the [dedicated section](/docs/guide/deployment#docker).\n\n---\n\n## Build your application\n\nThe principal aim of Mineral is to simplify the developer experience. \nThat's why we've created a simple command to build your application and create an executable. \n\nThis executable is a single file that you can deploy anywhere, without having to worry about dependencies or other configuration. \n\nBesides, this allows you to share only the executable with your customers and not all the source code.\n\n> [!warning]\n> Dart creates an executable for your operating system. If you build on Windows, you will receive a Windows executable which doesn't work on Linux.\n\nWe're using the `dart compile exe` command to build your application in `dist` directory.\n\n:::code-group auto\n```bash\ndart compile exe bin/main.dart -o ./dist/main.exe\n```\n:::\n\n---\n\n## Deploy with pm2\n\nPM2 is a production process manager for any applications that helps you keep applications alive forever and reload them without downtime. It plays a crucial role in deployment by managing your application's lifecycle, handling crashes, and providing monitoring capabilities.\n\n:::code-group labels=[ecosystem.config.js]\n```js\nmodule.exports = {\n  apps: [\n    {\n      name: \"discord-bot\",\n      script: \"./dist/main.exe\",\n      interpreter: \"none\",\n      watch: false,\n      env: {\n        DART_ENV: \"production\",\n        TOKEN: \"your_token\",\n        DISCORD_REST_API_VERSION: 10,\n        DISCORD_WS_VERSION: 10,\n        INTENT: \"3276799\",\n        LOG_LEVEL: \"TRACE\"\n      },\n      error_file: \"./logs/err.log\",\n      out_file: \"./logs/out.log\",\n      log_date_format: \"YYYY-MM-DD HH:mm:ss\",\n      restart_delay: 5000\n    }\n  ]\n};\n```\n:::\n\n### Start PM2 and manage processes\n\nOnce your ecosystem configuration is set up, you can start and manage your application with PM2 :\n\n:::code-group labels=[start, list, logs, restart, stop]\n```bash\n# Start the application\npm2 start ecosystem.config.js\n```\n```bash\n# List all running processes\npm2 list\n```\n```bash\n# View logs\npm2 logs discord-bot\n```\n```bash\n# Restart the application\npm2 restart discord-bot\n```\n```bash\n# Stop the application\npm2 stop discord-bot\n```\n:::\n\n---\n\n## Docker\n\nDocker is a powerful cross-platform containerisation tool that is widely used in the professional world.\n\nBefore starting a deployment with Docker, please refer to the [official documentation](https://www.docker.com) to ensure that your installation is correct.\n\n### Build your image\n\nNow that your installation is done, we will create a Dockerfile at the root of our project with the following information. In our instructions we use the official Docker image of the Dart language.\n\n:::code-group auto\n```dockerfile\nFROM dart:stable AS build\n\nWORKDIR /app\nCOPY . /app\nWORKDIR /app\n\nRUN dart pub get\nRUN dart compile exe src/main.dart -o mineral\n\nFROM scratch\nCOPY --from=build /runtime /\nCOPY --from=build /app/mineral /app/\nCOPY --from=build /app/pubspec.yaml /\n\nCMD [\"/app/mineral\"]\n```\n:::\n\n---\n\n### Docker CLI\n\nNow that the Docker image is configured, all we have to do is build it with the following command and then start it.\n\n:::code-group labels=[build, start]\n```bash\ndocker build -t [name]:latest .\n```\n```bash\ndocker run -d --name [display_name] [name]\n```\n:::\n\n---\n\n### Docker Compose\n\nDocker Compose is a tool that allows you to manage multiple containers at the same time. It can be very useful if you want to deploy your application with a database for example.\n\nTo use it, you just have to create a docker-compose.yml file at the root of your project with the following information.\n\n:::code-group labels=[docker-compose]\n```yaml\nversion: '3.8'\n\nservices:\n  bot:\n    container_name: bot\n    image: mineral\n    restart: always\n    environment:\n      - DART_ENV=production\n      - TOKEN=your_token\n      - DISCORD_REST_API_VERSION=10\n      - DISCORD_WS_VERSION=10\n      - INTENT=3276799\n      - LOG_LEVEL=TRACE\n```\n:::\n\nIf you have chosen `Redis` as your caching solution, please add the service to the `docker-compose.yaml`.\n\n:::code-group labels=[docker-compose]\n```yaml\nversion: '3.8'\n\nservices:\n  bot:\n    container_name: bot\n    image: mineral\n    restart: always\n    # [!code ++:2]\n    depends_on:\n      - cache\n    environment:\n      - DART_ENV=production\n      - TOKEN=your_token\n      - HTTP_VERSION=10\n      - WSS_VERSION=10\n      - INTENT=3276799\n      - LOG_LEVEL=TRACE\n  # [!code ++:8]\n  cache:\n    container_name: cache\n    image: redis\n    restart: always\n    ports:\n      - '6380:6379'\n    environment:\n      - REDIS_PASSWORD=redis\n```\n:::\n\n---\n\n## Kubernetes\n\nKubernetes is a powerful container orchestration platform that provides advanced deployment, scaling, and management capabilities for containerized applications. It's particularly useful for production environments where you need high availability, automatic scaling, and robust service discovery.\n\n### Prerequisites\n\nBefore deploying to Kubernetes, ensure you have:\n- A Kubernetes cluster (local with Minikube, cloud provider, or self-hosted)\n- `kubectl` CLI tool installed and configured\n- Your Docker image pushed to a container registry\n- Helm installed (for Helmfile deployment)\n\n### Basic Kubernetes Deployment\n\nCreate a basic Kubernetes deployment manifest for your Mineral application\n\n\nWe will consider the following structure for our application :\n\n```\nâ”œâ”€â”€ kubernetes\nâ”‚  â””â”€â”€ chart\nâ”‚     â”œâ”€â”€ templates\nâ”‚     â”‚  â””â”€â”€ deployment.yaml\nâ”‚     â”œâ”€â”€ Chart.yaml\nâ”‚     â””â”€â”€ values.yaml\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”œâ”€â”€ lib\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\n> [!warning]\n> You cannot use replicas because the bot is a client who subscribe to the Discord websocketgateway.\n> If you run `N` instances of the bot, you will have `N` identical events.\n\n:::code-group labels=[chart.yaml, deployment.yaml, values.yaml]\n```yaml\napiVersion: v2\nname: mineral-bot\ndescription: A Helm chart for Mineral Discord Bot\ntype: application\nversion: 0.1.0\nappVersion: \"1.0.0\"\n```\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mineral-bot\n  labels:\n    app: mineral-bot\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: mineral-bot\n  template:\n    metadata:\n      labels:\n        app: mineral-bot\n    spec:\n      containers:\n      - name: mineral-bot\n        image: your-registry/mineral:latest\n        env:\n          - name: DART_ENV\n            value: {{ .Values.dartEnv | quote  }}\n          - name: DISCORD_REST_API_VERSION\n            value: {{ .Values.discordRestApiVersion | quote  }}\n          - name: DISCORD_WS_VERSION\n            value: {{ .Values.discordWsVersion | quote  }}\n          - name: INTENT\n            value: {{ .Values.intent | quote  }}\n          - name: LOG_LEVEL\n            value: {{ .Values.logLevel | quote  }}\n          - name: TOKEN\n            valueFrom:\n              secretKeyRef:\n                name: {{ .Values.kubeSecret }}\n                key: token\n```\n```yaml\ndartEnv: production\ndiscordRestApiVersion: 10\ndiscordWsVersion: 10\nintent: '3276799'\nlogLevel: trace\n\nkubeSecret: mineral-credentials\n```\n:::\n\n---\n\n### Deploy with Helmfile\n\nHelmfile is a declarative way to deploy Helm charts, making it easier to manage complex Kubernetes deployments across multiple environments.\n\nWe will consider the following structure for our application :\n\n```\nâ”œâ”€â”€ kubernetes\nâ”‚  â”œâ”€â”€ chart\nâ”‚  â”‚  â”œâ”€â”€ templates\nâ”‚  â”‚  â”‚  â””â”€â”€ deployment.yaml\nâ”‚  â”‚  â”œâ”€â”€ Chart.yaml\nâ”‚  â”‚  â””â”€â”€ values.yaml\nâ”‚  â”‚\n// [!code ++:9]\nâ”‚  â””â”€â”€ helmfiles\nâ”‚     â”œâ”€â”€ helmfile.yaml\nâ”‚     â”‚\nâ”‚     â””â”€â”€ templates\nâ”‚        â”œâ”€â”€ development\nâ”‚        â”‚  â””â”€â”€ values.yaml\nâ”‚        â”‚\nâ”‚        â””â”€â”€ production\nâ”‚           â””â”€â”€ values.yaml\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”œâ”€â”€ lib\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nCreate a `helmfile.yaml` to manage your deployment:\n\n:::code-group labels=[helmfile.yaml]\n```yaml\nenvironments:\n  development:\n  production:\n---\nreleases:\n  - name: mineral-bot\n    namespace: mineral\n    chart: ../chart\n    version: 0.1.0\n    values:\n      - ./{{ .Environment.Name }}/values.yaml\n```\n:::\n\n#### Environment-specific Values\n\nCreate environment-specific value files:\n\n:::code-group labels=[[environment]/values.yaml]\n```yaml\nimage:\n  tag: \"xxxxx\"\n```\n:::\n\n#### Deploy with Helmfile\n\nDeploy your application using Helmfile:\n\n:::code-group labels=[deploy]\n```bash\n# Deploy to the target environment\nhelmfile sync -f ./kubernetes/helmfiles/helmfile.yaml -e [environment]\n\n# List releases\nhelmfile -f ./kubernetes/helmfiles/helmfile.yaml list\n\n# Delete deployment\nhelmfile -f ./kubernetes/helmfiles/helmfile.yaml delete\n```\n:::\n\nThis Kubernetes and Helmfile setup provides a production-ready deployment with :\n- Multi-environment support\n- Health checks and monitoring\n- Redis integration\n- Secret management","src/content/docs/guide/deployment.mdx","ace88b45dc0f68ee","event",{"id":53,"data":55,"body":60,"filePath":61,"digest":62,"deferredRender":22},{"title":56,"description":29,"permalink":57,"order":58,"icon":59},"Events","events",4,"lucide:bell","# Events\n\nThe Discord API uses a real-time event system transmitted via a WebSocket connection to allow client applications to receive instant updates from the server.\n\n> [!important]\n> Please see the dedicated [section](/docs/api/events) for more information.\n\n---\n\n## Introduction\n\nWhen a bot or application connects to the Discord gateway, it receives a continuous stream of events, such as new messages, user status changes, channel changes, and much more.\n\nAn event listener is a function that listens to a specific event and triggers an action when the event is dispatched.\n\nBasically, Mineral offers an event system that can be used in two different ways.\n\n---\n\n## Functional approach\n\nLet's take a simple example of a bot that listens to the `MessageCreate` event and prints the message content to the console.\n\nFrom the `Client`, we can chain event listeners using the following pattern :\n\n:::code-group labels=[boilerplate, main.dart]\n```dart\nclient.events.\u003Ccontext>.\u003Cevent>(\u003Clistener>)\n```\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.events.server.messageCreate((message) {\n    print(message.content);\n  });\n\n  await client.init();\n}\n```\n:::\n\n---\n\n## Object-oriented approach\n\nFor benchmarking purposes, we recommend using the `functional` approach, but when developing applications requiring \nmore than 2 events or commands, we recommend using the object-oriented approach.\n\n:::code-group labels=[boilerplate, message_create.dart, main.dart]\n```dart\nfinal class \u003CClassName> extends \u003CEvent> {\n  @override\n  FutureOr\u003Cvoid> handle(\u003Cparams>) {\n    // Your business code here\n  }\n}\n```\n```dart\nfinal class MessageCreate extends MessageCreateEvent {\n  @override\n  void handle(ServerMessage message) {\n    print(message.content);\n  }\n}\n```\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.register(MessageCreate.new);\n\n  await client.init();\n}\n```\n:::","src/content/docs/guide/event.mdx","fe69b732d142a3d3","structure",{"id":63,"data":65,"body":69,"filePath":70,"digest":71,"deferredRender":22},{"title":66,"description":29,"permalink":63,"order":67,"icon":68},"Structure",2,"lucide:folder-tree","# Structure\n\nThe folder structure of a project is very important.\nIt helps you to organize your project in a better way. It also helps you to understand the project structure easily.\n\nIn this guide, we will discuss the folder structure of a project.\n\n---\n\n## Minimal structure\n\nThe minimal structure proposed by the project consists of a simple source folder containing your business code.\nThe `bin` folder is used to use the `hmr` component in your application during the development phase; you can change the name of the `source` folder, but we do not recommend deleting it.\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ lib\nâ”‚  â”œâ”€â”€ events\nâ”‚  â””â”€â”€ commands\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nThis architecture is classic in the world of Discord bots. It's simple yet meets the need for rapid implementation.\n\nOne of the limitations arises when your application grows more or less drastically: you'll end up with a multitude of files at the same level, which can lead to poor understanding of your application.\n\n---\n\n## N-tier structure\n\nWhen you're developing increasingly complex applications, you generally lose readability and maintainability\nand maintainability if you don't focus on a stable, future-proof software architecture.\n\n> [!note]\n> We recommend the following structure.\n\nOne approach we recommend is the module-based architecture.\nThis involves dividing your application into several business modules that are independent of each other.\n\n```\nâ”œâ”€â”€ assets\nâ”‚  â”œâ”€â”€ image1.png\nâ”‚  â””â”€â”€ image2.png\nâ”‚\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ lib\nâ”‚  â”œâ”€â”€ commons\nâ”‚  â”‚  â”œâ”€â”€ helper.dart\nâ”‚  â”‚  â””â”€â”€ api.dart\nâ”‚  â”‚\nâ”‚  â”œâ”€â”€ first_module\nâ”‚  â”‚  â”œâ”€â”€ events\nâ”‚  â”‚  â”œâ”€â”€ commands\nâ”‚  â”‚  â””â”€â”€ provider.dart\nâ”‚  â”‚\nâ”‚  â””â”€â”€ second_module\nâ”‚     â”œâ”€â”€ events\nâ”‚     â”œâ”€â”€ commands\nâ”‚     â””â”€â”€ provider.dart\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nThis architecture has several notable advantages: it allows you to:\n- divide your application code into modules, each representing a business fragment\n- simplifies the integration of your code across multiple projects thanks to [`providers`](/docs/api/providers)\n\nIn this architecture, we use [`providers`](/docs/api/providers) allowing us to \"move\" the entry point of our module in order to facilitate the segmentation of our code.\n\nTo simplify the management of your modules, we recommend that you create a `provider.dart` file within each which will\nserve as the entry point for each module.\n\n:::code-group labels=[main.dart, module/provider.dart]\n```dart\nfinal client = Client()\n  .registerProvider(Provider.new) // [!code ++]\n  .build();\n```\n\n```dart\nfinal class Provider extends Provider {\n  final MineralClientContract _client;\n\n  Provider(this._client) {\n    _client.register(MyEvent.new); // [!code ++]\n    _client.registerCommand(MyCommand.new); // [!code ++]\n  }\n}\n```\n:::\n\n---\n\n## Layered architecture\n\nWhen we talk about modular architecture, we quickly come to hexagonal architecture.\nThis architecture allows you to decouple the different parts of your application according to their core business and\nresponsibility within it.\n\n> [!note]\n> We recommend the following structure.\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ lib\nâ”‚  â”œâ”€â”€ ui\nâ”‚  â”‚  â”œâ”€â”€ events\nâ”‚  â”‚  â”‚  â”œâ”€â”€ ready_event.dart\nâ”‚  â”‚  â”‚  â””â”€â”€ message_create_event.dart\nâ”‚  â”‚  â”‚\nâ”‚  â”‚  â””â”€â”€ commands\nâ”‚  â”‚     â””â”€â”€ foo_command.dart\nâ”‚  â”‚\nâ”‚  â”œâ”€â”€ services\nâ”‚  â”‚  â””â”€â”€ foo_service.dart\nâ”‚  â”‚\nâ”‚  â”œâ”€â”€ data\nâ”‚  â”‚  â”œâ”€â”€ models\nâ”‚  â”‚  â””â”€â”€ repositories\nâ”‚  â”‚\nâ”‚  â””â”€â”€ provider.dart\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nThe above structure is an example that we recommend to help you adopt a modular, scalable and maintainable architecture by decoupling the different parts of your application as much as possible.\nHowever, it will not always suit your business needs and will need to be adapted accordingly.\n\n| Directory | Description |\n|----------|-------------|\n| `ui` | Contains the various parts of your application which are related to your business, including `events` and `commands`. |\n| `services` | Contains the services which allow you to manipulate the data in your application; they will generally be used from the `ui`. |\n| `data` | Contains the DTOs and repositories that allow you to manipulate the data in your application. An example of use is the use of a remote REST service to which you need to make HTTP calls. |\n| `provider` | The entry point of your module who's call under the `main` file. |\n\n---\n\n## Hexagonal architecture\n\nWhen we talk about modular architecture, we quickly come to hexagonal architecture.\nThis architecture allows you to decouple the different parts of your application according to their core business and\nresponsibility within it.\n\n> [!note]\n> We recommend the following structure.\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ lib\nâ”‚  â””â”€â”€ application\nâ”‚  â”‚  â””â”€â”€ tickets\nâ”‚  â”‚     â”œâ”€â”€ commands\nâ”‚  â”‚     â”œâ”€â”€ events\nâ”‚  â”‚     â””â”€â”€ ticket_provider.dart\nâ”‚  â”‚\nâ”‚  â”œâ”€â”€ domain\nâ”‚  â”‚  â””â”€â”€ tickets\nâ”‚  â”‚     â”œâ”€â”€ entities\nâ”‚  â”‚     â”œâ”€â”€ repositories\nâ”‚  â”‚     â”œâ”€â”€ dtos\nâ”‚  â”‚     â””â”€â”€ contracts\nâ”‚  â”‚\nâ”‚  â””â”€â”€ infrastructure\nâ”‚     â””â”€â”€ tickets\nâ”‚        â”œâ”€â”€ repositories\nâ”‚        â””â”€â”€ dtos\nâ”‚   \nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nThis architecture has several notable advantages: it allows you to:\n- divide your application code into modules, each representing a business fragment\n- simplifies the integration of your code across multiple projects thanks to [`providers`](/docs/api/providers)\n- isolate the business logic of your application from the infrastructure layer\n\nThe `application` directory contains all of our business context divided into modules, allowing better readability and maintainability of our code.\n\n| Directory | Description |\n|----------|-------------|\n| `bin` | Contains the entry point of your application. |\n| `application` | Contains the various parts of your application which are related to your business, including `events`, `commands`, `states` or any mineral component, it can be split into modules. |\n| `domain` | Contains the entities, DTOs, repositories, contracts that allow you to manipulate the data in your application. He contains the business logic of your application and must not depend on anything other than itself. |\n| `infrastructure` | Contains implementations that must interact with external services such as APIs, BDDs and queues. Each implementation must implement a contract defined in the domain. |\n\n> [!note]\n> You can find a sample implementation of this architecture [here](https://github.com/LeadcodeDev/mineral_beta_bot_demo).","src/content/docs/guide/structure.mdx","b64b48dd7bb0d01e","installation",{"id":72,"data":74,"body":78,"filePath":79,"digest":80,"deferredRender":22},{"title":75,"description":29,"permalink":72,"order":76,"icon":77},"Installation",1,"lucide:play","# Installation\n\nBefore embarking on this crazy discord adventure, you will need to follow the steps outlined below to set up a clean and healthy project.\n\n---\n\n## Prerequisites\nPlease make sure you have the following tools installed on your machine before you start.\n\n### Dart lang\nThe Mineral framework has been developed entirely in the Dart programming language, so you will need to install it in your development environment first. In order to best install it, please refer to the [official documentation](https://dart.dev/get-dart).\n\n> [!note]\n> The version of the Dart language sdk must be at least `^3.5.2`.\n\n---\n\n## Setup new project\n\n### From the CLI\n\nYou can use the Mineral CLI to create a new project.\n\nFollow the steps below to install the CLI.\n\n:::code-group auto\n```bash\ndart pub global activate mineral_cli [version]\n\ncd path/to/your/projects\nmineral create my_project\n```\n:::\n\n> [!note]\n> More details about the CLI can be found in the [`command line`](/docs/api/cli) section.\n\n---\n\n### From scratch\n\nUse the following command to start a new blank Dart project.\n```bash\ndart create my_project\n```\n\nAfter creating the project, you will need to add the Mineral framework to your `pubspec.yaml` file.\n\n:::code-group labels=[pubspec.yaml]\n```yaml\ndependencies:\n  mineral: ^4.0.0-dev.11\n  mineral_cache: ^1.0.0-dev.4\n```\n:::\n\n> [!note]\n> Please verify the lasted version of the [`core`](https://pub.dev/packages/mineral) and [`cache`](https://pub.dev/packages/mineral_cache) packages directly on registry.\n\nThen run the following command to install the dependencies.\n\n:::code-group auto\n```bash\ndart pub get\n```\n:::\n\nMake sure you have the following minimal structure in your project.\nThe `.env` file is not created by default when you start a new Dart project, don't forget to create it.\n\n:::code-group labels=[boilerplate, .env]\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n```dotenv\nDART_ENV=development\nTOKEN=your_discord_token\nDISCORD_REST_API_VERSION=12\nDISCORD_WS_VERSION=12\nINTENT=3276799\nLOG_LEVEL=info\n```\n:::\n\n### Application\n\nThe `main.dart` file is the entry point of your application. This is where you will start your bot.\n\n:::code-group labels=[main.dart]\n```dart\nvoid main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  await client.init();\n}\n```\n:::\n\nTo check that your application is working properly, we recommend that you use the `ready` event.\n\n:::code-group labels=[main.dart]\n```dart\nvoid main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n  \n  // [!code ++:3]\n  client.events.ready((Bot bot) {\n    client.logger.info('${bot.username} is ready ! ðŸš€');\n  });\n\n  await client.init();\n}\n```\n:::\n\n## Running the application\n\nFinally, you can run your application with the following command.\n\n:::code-group auto\n```bash\ndart run src/main.dart\n```\n:::","src/content/docs/guide/installation.mdx","a8ce7a8a0ab4fda3","api",["Map",83,84,91,92,25,99,35,104,53,109,113,114,121,122,128,129,137,138,145,146,155,156,164,165],"cli",{"id":83,"data":85,"body":88,"filePath":89,"digest":90,"deferredRender":22},{"title":86,"description":29,"permalink":83,"order":58,"icon":87},"Command Line Interface","lucide:terminal","# Command Line Interface","src/content/docs/api/cli.mdx","b3f9d81e4bbc5319","components",{"id":91,"data":93,"body":96,"filePath":97,"digest":98,"deferredRender":22},{"title":94,"description":29,"permalink":91,"order":58,"icon":95},"Components","lucide:layout-dashboard","# Components","src/content/docs/api/components.mdx","5d30078fbac63544",{"id":25,"data":100,"body":101,"filePath":102,"digest":103,"deferredRender":22},{"title":28,"description":29,"permalink":25,"order":39,"icon":31},"# Events","src/content/docs/api/commands.mdx","48fdb2a30ac547dc",{"id":35,"data":105,"body":106,"filePath":107,"digest":108,"deferredRender":22},{"title":38,"description":29,"permalink":35,"order":76,"icon":40},"# Environment variables\n\nEnvironment variables serve the purpose of storing secrets like the database password, the app secret, or an API key outside of your application codebase.\n\nIn addition, environment variables can be used to obtain different configurations depending on the environment, such as the use of a secret to use an API or database identifiers.\n\n---\n\n## Introduction\nNormally, environment variables are accessible via Dart's `Platform` class, but this is said to be immutable, so we can't add data relating to our application to it.\n\nSo we're providing an `Environment` class to access the various environment variables in your application.\n\n> [!important]\n> Environment variable management is deported to an agnostic package [`env_guard`](https://pub.dev/packages/env_guard) created for this purpose and which can be used in any Dart or Flutter project.\n\n\nThe environment management is done from the `Env` class which is made available from the `env_guard` package.\n\n:::code-group labels=[env.dart]\n```dart\nabstract interface class Env {\n  T get\u003CT>(String key, {T? defaultValue});\n\n  Map\u003CString, dynamic> validate(\n    Map\u003CString, EnvSchema> schema,\n    Map\u003CString, dynamic> data,\n  );\n\n  void define(\n    Map\u003CString, EnvSchema> schema, {\n    Directory? root,\n    bool includeDartEnv = true,\n  });\n\n  void defineOf\u003CT extends DefineEnvironment>(T Function() source, { \n    Directory? root, \n    bool includeDartEnv = true \n  });\n}\n```\n:::\n\nWe recommend that you use an `.env` environment file to store your environment variables as far as possible, although you can inject your variables using your CLI.\n\n:::code-group auto\n```bash\ndart run src/main.dart --dart-define=MY_VARIABLE=\"Hello World\"\n```\n:::\n\n> [!note]\n> See more in Dart's [documentation](https://dart.dev/guides/environment-declarations).\n\n\n:::code-group labels=[.env, main.dart, schema.dart]\n```dotenv\nDART_ENV=development\nTOKEN=your_token\nDISCORD_REST_API_VERSION=10\nDISCORD_WS_VERSION=10\nINTENT=3276799\nLOG_LEVEL=TRACE\n```\n```dart\nvoid main() {\n  env.defineOf(AppEnv.new);\n}\n```\n```dart\nfinal class AppEnv implements DefineEnvironment {\n  static final String host = 'HOST';\n  static final String port = 'PORT';\n  static final String uri = 'URI';\n\n  @override\n  final Map\u003CString, EnvSchema> schema = {\n    host: env.string().optional(),\n    port: env.number().integer(),\n    uri: env.string(),\n  };\n}\n```\n:::","src/content/docs/api/environment-variables.mdx","c03df1459a03abfd",{"id":53,"data":110,"body":101,"filePath":111,"digest":112,"deferredRender":22},{"title":56,"description":29,"permalink":57,"order":67,"icon":59},"src/content/docs/api/event.mdx","084a5b1dae0ee378","interactive-components",{"id":113,"data":115,"body":118,"filePath":119,"digest":120,"deferredRender":22},{"title":116,"description":29,"permalink":113,"order":30,"icon":117},"Interactive Components","lucide:mouse-pointer-2","# Interactive Components","src/content/docs/api/interactive-components.mdx","f5074ca845ff9800","global-states",{"id":121,"data":123,"body":101,"filePath":126,"digest":127,"deferredRender":22},{"title":124,"description":29,"permalink":121,"order":48,"icon":125},"Global States","lucide:brain","src/content/docs/api/global-states.mdx","d87723dff539a66f","placeholders",{"id":128,"data":130,"body":134,"filePath":135,"digest":136,"deferredRender":22},{"title":131,"description":29,"permalink":128,"order":132,"icon":133},"Placeholders",7,"lucide:hash","# Placeholders","src/content/docs/api/placeholders.mdx","333761a65eb152fa","providers",{"id":137,"data":139,"body":142,"filePath":143,"digest":144,"deferredRender":22},{"title":140,"description":29,"permalink":137,"order":39,"icon":141},"Providers","lucide:picture-in-picture","# Providers","src/content/docs/api/providers.mdx","469eabfec877e4e2","container",{"id":145,"data":147,"body":152,"filePath":153,"digest":154,"deferredRender":22},{"title":148,"description":149,"permalink":145,"order":150,"icon":151},"Service container","Service container is a container that holds the services for the application.",10,"lucide:box","# Service container\n\nIoC is a concept that allows services to be defined in a container and then used in the rest of the application via a\nsingle instance.\napplication using a single instance.\n\nIt improves the modularity and reusability of the code, as well as its testability.\n\n---\n\n## Introduction\n\nInversion of Control (`IoC`) is a design principle used in software development to increase the modularity and flexibility\nof code. It involves delegating the control of certain aspects of a program, such as the creation and management of\nobjects, to a container or framework.\n\nThis approach allows developers to focus on the business logic of their application while the IoC container handles the\ninstantiation and lifecycle of dependencies.\n\n### Benefits\n\n- **Decoupling :** IoC reduces the tight coupling between components, making the system more adaptable to changes. Ease of Maintenance: With a clear separation of concerns, maintaining and updating the code becomes more straightforward.\n- **Testability :** Dependencies can be injected, making it easier to write unit tests and achieve higher test coverage.\n- **Flexibility :** It provides the flexibility to change implementations without modifying the dependent code, facilitating easier updates and maintenance.\n\n## How it works\n\nIn your applications, it is common to want to share services between several components such as\nrepositories, services, configurations, etc.\n\nIoC simplifies the task by allowing you to define these services in a central container and use them in the rest of the application via a single instance.\nthe rest of the application via a single instance.\n\n> [!note]\n> Follow [this link](https://refactoring.guru/design-patterns/singleton) to learn more about `Singleton` pattern.\n\n## Basic usage\n\nWithin the Mineral framework, we have decided not to use code generation (judging a lack of\ncontrol), which means writing additional code in order to make full use of IoC.\n\nBasically, an IoC involving service injection consists of two stages.\n\n1. Creation of a service in the form of a class\n2. Call of the service by a consumer. If the service exists, it is injected, otherwise it is instantiated and then injected.\n\n## Mineral usage\n\nIn the Dart language, it is impossible to locate the services called without using reflection,\nbut using it means that you can no longer compile the application to `jit`, `aot`, `exe`... because this reflection only\nonly works within the Dart VM.\n\nAs it is, we have to inject our services ourselves.\n\n> [!note]\n> With the announcement and development of `macros` in Dart, it is possible that we will be able to automate this task of\n> instantiation task.\n\n### Create a service\n\n:::code-group labels=[service.dart]\n```dart\nfinal class MyClass {\n  void sayHello() => print('Hello World');\n}\n```\n:::\n\n### Register and resolve the service\n\nThere are two ways of registering our service with the IoC :\n\n1. bind: registers a service without returning it.\n2. make: registers a service and returns it.\n\n> [!warning]\n> It is not possible to retrieve a service not previously instantiated in the IoC.\n\n:::code-group labels=[binding, making]\n```dart\nvoid main() {\n  ioc.bind(MyClass.new);\n\n  final service = ioc.resolve\u003CMyClass>();\n  service.sayHello();\n}\n```\n\n```dart\nvoid main() {\n  final service = ioc.make(MyClass.new);\n  service.sayHello();\n}\n```\n:::\n\nIn order to abstract a service, it is also possible to give an `interface` instead of a direct implementation.\n\n:::code-group labels=[main.dart,service.dart, contract]\n```dart\nvoid main() {\n   // [!code --:2]\n  ioc.bind(MyClass.new);\n  final service = ioc.resolve\u003CMyClass>();\n\n // [!code ++:2]\n  ioc.bind\u003CMyClassContract>(MyClass.new);\n  final service = ioc.resolve\u003CMyClassContract>();\n\n  service.sayHello();\n}\n```\n```dart\nfinal class MyClass implements MyClassContract {\n  void sayHello() => print('Hello World');\n}\n```\n```dart\nabstract interface class MyClassContract {\n  void sayHello();\n}\n```\n:::","src/content/docs/api/container.mdx","6c5bb667dd109163","hmr",{"id":155,"data":157,"body":101,"filePath":162,"digest":163,"deferredRender":22},{"title":158,"description":159,"permalink":155,"order":160,"icon":161},"Hot Module Replacement","Hot Module Replacement is a feature that allows you to replace a module without reloading the page.",11,"lucide:zap","src/content/docs/api/hmr.mdx","0ba7636e50dcb7c2","datastore",{"id":164,"data":166,"body":101,"filePath":171,"digest":172,"deferredRender":22},{"title":167,"description":168,"permalink":164,"order":169,"icon":170},"Datastore","Data store is a concept that allows you to store the data for the application.",12,"lucide:satellite-dish","src/content/docs/api/datastore.mdx","fdbc6815fdc469d0","concepts",["Map",175,176,184,185],"data-caching",{"id":175,"data":177,"body":181,"filePath":182,"digest":183,"deferredRender":22},{"title":178,"description":179,"permalink":175,"order":67,"icon":180},"Data caching","Data caching is a mechanism that caches the data for the application.","lucide:database","# Data Caching\n\nWhen developing a Discord application, it is customary to save objects in memory. This has the advantage of making them instantly accessible, but also of preserving their integrity.\n\n---\n\n## Problem\nOn the scale of a small application, this does not have any harmful effects, but as your application evolves and has to accommodate more and more members, the memory is used more and more until it reaches a threshold that we call \"no return\", which in some cases can more or less impact the entire infrastructure on which your application is hosted.\n\n## Concrete example\n\nLet's imagine the hypothetical case of an application that has to support more than 5,000 Discord servers, each with more than 300,000 members.\n\n> [!note]\n> The values taken as examples, such as the number of Discord servers and the number of members on each, are hypothetical and fictitious.\n\nThis mass of data represents a considerable load on the memory of the machine hosting your application.\n\nTraditionally it is chosen to remove the existing Discord interaction library in its preferred language in order to abstract itself from its data management method, so the application reverts to a state of API call to the HTTP API and traditional listening on the Discord websocket in order to no longer depend on your application's memory.\n\n## Caching system\nThanks to Mineral's caching system, the management of this memory is deported to a caching provider that allows you to move this memory when it is needed, so you can move it to another machine.\n\nThanks to the Dart language, we can compile our applications in order to drastically reduce our power consumption. To this end, and in order to reduce this consumption as much as possible, which in some cases remains high, we are providing a caching service that can be used to deport the location of objects currently in memory to a remote service.\n\n> [!warning]\n> Please note that depending on your chosen caching solution, certain costs may apply.\n> This is particularly visible on cloud solutions that calculate your rates based on consumption.\n\nThe Mineral framework offers official support for several caching providers.\n\n---\n\n### Memory Provider\nThis is the simplest caching solution, as it simply stores the data in memory.\n\nTo use it, you need to add the `mineral_cache` package to your `pubspec.yaml` file and then declare its use in your Mineral client builder.\n\n:::code-group labels=[main.dart, pubspec.yaml]\n```dart\nfinal client = ClientBuilder()\n  .setCache(MemoryProvider.new) // [!code ++]\n  .build();\n```\n\n```yaml\ndependencies:\n  mineral_cache: ^0.0.1 # [!code ++]\n```\n:::\n\n> [!note]\n> No environment variable is required to use this provider.\n\n---\n\n### Redis Provider\nBased on a powerful caching solution, the Redis provider allows you to deport your growing memory to an external solution.\n\nTo use it, you need to add the `mineral_cache` package to your `pubspec.yaml` file and then declare its use in your Mineral client builder.\n\n:::code-group labels=[main.dart, pubspec.yaml]\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .setCache((_) => RedisProvider(\n      host: 'localhost',\n      port: 6379,\n      password: 'password',\n    ))\n    .build();\n}\n```\n```yaml\ndependencies:\n  mineral_cache: ^0.0.1 # [!code ++]\n```\n:::\n\nTo simplify the injection of environment variables, the provider provides an `factory` to used environment variables as default values.\n\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    // [!code --:5]\n    .setCache((_) => RedisProvider(\n      host: 'localhost',\n      port: 6379,\n      password: 'password',\n    ))\n    .setCache(RedisProvider.fromEnvironment) // [!code ++]\n    .build();\n}\n```\n\n> [!note]\n> It is important to note that using the `factory` automatically validates the variables required in your environment.\n\nThe minimum environment variables are :\n\n:::code-group labels=[.env, schema.dart]\n```dotenv\nREDIS_HOST=127.0.0.1\nREDIS_PORT=6380\nREDIS_PASSWORD=redis\n```\n```dart\nfinal class RedisEnv implements DefineEnvironment {\n  static final String redisHost = 'REDIS_HOST';\n  static final String redisPort = 'REDIS_PORT';\n  static final String redisPassword = 'REDIS_PASSWORD';\n\n  @override\n  final Map\u003CString, EnvSchema> schema = {\n    redisHost: env.string(),\n    redisPort: env.number(),\n    redisPassword: env.string(),\n  };\n}\n```\n:::\n\n## Extending the Cache Provider\nIf you want to use a caching solution that is not officially supported, you can extend Mineral's caching system by creating your own provider.\n\nTo do this, you need to create a class that extends the `CacheProvider` class and implement the methods that are required.\n\n:::code-group labels=[my_provider.dart, contract.dart]\n```dart\nfinal class MyProvider implements CacheProviderContract {\n  @override\n  String get name => 'my_provider';\n\n  @override\n  late final LoggerContract logger;\n  \n  // Implement all required methods and properties\n  // provided by the CacheProviderContract.\n}\n```\n\n```dart\nabstract interface class CacheProviderContract {\n  String get name;\n\n  abstract LoggerContract logger;\n\n  FutureOr\u003Cvoid> init();\n\n  Future\u003Cint> length();\n  Future\u003CList\u003CT>> getAll\u003CT extends dynamic>();\n  Future\u003CString?> get(String? key);\n  Future\u003CString> getOrFail(String key, { Exception Function()? onFail });\n  Future\u003Cbool> has(String key);\n  Future\u003Cvoid> put\u003CT>(String key, T object);\n  Future\u003Cvoid> remove(String key);\n  Future\u003Cvoid> removeMany(List\u003CString> key);\n  Future\u003Cvoid> clear();\n\n  Future\u003Cvoid> dispose();\n  Future\u003Cbool> getHealth();\n}\n```\n:::\n\nThen you can use your provider like this.\n```dart\nvoid main(_, port) {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .setCache((_) => MyProvider()) // [!code highlight]\n    .build();\n}\n```\n\nIf you want to use environment variables to configure your provider, you can create an `factory` named `fromEnvironment` to simplify injecting them.\n\n:::code-group labels=[main.dart, my_provider.dart, schema.dart]\n```dart\nvoid main(_, port) {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .setCache((_) => MyProvider()) // [!code --]\n    .setCache(MyProvider.fromEnvironment) // [!code ++]\n    .build();\n}\n```\n```dart\nfinal class MyProvider implements CacheProviderContract {\n  // Your complete implementationâ€¦\n  \n  factory MyProvider.fromEnvironment(env) {\n    // Validate before returning provider\n    env.defineOf(MyProviderEnv.values);\n    \n    return MyProvider();\n  }\n}\n```\n\n```dart\nfinal class MyProviderEnv implements DefineEnvironment {\n  static final String myHost = 'MY_HOST';\n  static final String myPort = 'MY_PORT';\n  static final String myPassword = 'MY_PASSWORD';\n\n  @override\n  final Map\u003CString, EnvSchema> schema = {\n    myHost: env.string(),\n    myPort: env.number(),\n    myPassword: env.string(),\n  };\n}\n```\n:::","src/content/docs/concepts/data-caching.mdx","4451b90e73578b72","immutability",{"id":184,"data":186,"body":190,"filePath":191,"digest":192,"deferredRender":22},{"title":187,"description":188,"permalink":184,"order":76,"icon":189},"Immutability","Immutability is a concept that ensures the data is not modified after it is created.","lucide:lock","# Immutability\n\nImmutability is a core concept in functional programming and software development that ensures the state of an object\ncannot be modified after it is created. This principle helps in creating predictable and maintainable code by avoiding\nside effects and ensuring that data remains consistent throughout the application lifecycle.\n\n---\n\n## Benefits\n\n- **Predictability**: Immutable objects provide a predictable state, making it easier to reason about the code.\n- **Debugging**: Debugging becomes simpler as the state of an object does not change unexpectedly.\n- **Cacheability**: Immutable objects can be safely cached and reused without the risk of modification.\n\n---\n\n## Impact on the code\n\nIn Mineral, data objects are immutable by default.\nThis means that once an object is created, its state cannot be changed.\n\n> [!note]\n> If you need to compare an old object with a new one, you should get a new object from the API.\n\nIt is important to note that every event received by Discord events is made immutable by default.\nThis means that when you try to perform an asynchronous action to Discord's HTTP API, the object used as the access\npoint to the method will not be altered despite the success of the operation.\n\n:::code-group labels=[main.dart]\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.events.server.serverCreate((server) async {\n    await server.setName('New Server');\n    \n    // Server name is still the same\n    assert(server.name != 'New Server');\n  });\n\n  await client.init();\n}\n```\n:::","src/content/docs/concepts/immutability.mdx","b5684a9d83fecf09","examples",["Map",195,196],"ping-pong",{"id":195,"data":197,"body":201,"filePath":202,"digest":203,"deferredRender":22},{"title":198,"description":199,"permalink":195,"order":76,"icon":200},"Ping Pong","Ping Pong is a simple example that shows how to use the framework.","lucide:ping-pong","# Ping Pong","src/content/docs/examples/ping-pong.mdx","5a2393e4b8593b82"]