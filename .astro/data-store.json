[["Map",1,2,9,10,40,41,52,53,151,152,192,193,222,223],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.10.2","content-config-digest","bbca7583471c0039","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"prefetch\":true,\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"mermaid\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{\"light\":\"github-light\",\"dark\":\"catppuccin-frappe\"},\"wrap\":false,\"transformers\":[{\"name\":\"@shikijs/transformers:notation-diff\"},{\"name\":\"@shikijs/transformers:notation-highlight\"},{\"name\":\"@shikijs/transformers:notation-highlight-word\"},{\"name\":\"@shikijs/transformers:notation-focus\"},{\"name\":\"@shikijs/transformers:notation-error-level\"},{\"name\":\"@shikijs/transformers:meta-highlight\"}]},\"remarkPlugins\":[null,null],\"rehypePlugins\":[null,[null,{\"customClassNames\":{\"calloutClass\":\"callout\",\"calloutTitleClass\":\"callout-title\",\"calloutContentClass\":\"callout-content\"}}],null,null],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false},\"legacy\":{\"collections\":false}}","preface",["Map",11,12,22,23,31,32],"contribute",{"id":11,"data":13,"body":18,"filePath":19,"digest":20,"deferredRender":21},{"title":14,"description":15,"permalink":11,"order":16,"icon":17},"Contribute","Lorem ipsum dolor sit amet, consectetur adipiscing elit.",3,"lucide:wrench","# Contribute\n\nContributions are the basis of any open-source project. They enable the project to evolve, fix bugs, add features and much more.\nWe're delighted that you want to contribute to our project !\n\n> [!important]\n> Your help is invaluable in improving and growing this project.\n\n---\n\n## How to contribute\n\nContributions can take several forms. Here are a few examples:\n\n- Improving the documentation with your feedback and experiments\n- Report and/or fixing bugs in [issues](https://github.com/mineral-dart/core/issues)\n- Adding missing functionalities through forks and pull requests\n- Suggest improvements to the user experience\n- Help the community by answering questions from other users\n\n---\n\n## Improving the documentation\n\nThe documentation is the first point of contact for users. It must be clear, concise and easy to understand.\n\nThis aspect of the project is crucial to its adoption and use by the community, but it takes up an infinite amount of\ntime to write, to the detriment of the actual development of new features.\n\n---\n\n### API documentation\n\nThe API documentation is generated using the `dartdoc` tool. It is automatically generated and updated with each new\nrelease.\n\nEach method must be documented, as well as each parameter, return type and exception.\nIt's this aspect in particular that consumes an infinite amount of our time.\n\nSi vous souhaitez-nus aider Ã  amÃ©liorer la documentation, vous pouvez suivre les Ã©tapes suivantes :\n\n1. Fork the project\n2. Make your `dartdoc` comments\n3. Push your changes and create a pull request\n\nYou can also use the following template to document the methods :\n\n````dart\n/// Title of the method\n///\n/// Description of the method\n///\n/// Example :\n/// ```dart\n/// // Code example\n/// ```\n///\nvoid fn() {}\n````\n\n### Website documentation\n\nThe framework documentation is the second most important part of the documentation.\nunderstand how to use the framework.\n\nUnlike API documentation, here we'll explain the concepts, functionalities and best practices, while providing\ntheoretical and concrete examples to help users understand how the framework works while providing theoretical and\npractical examples to help users understand how the framework works.\n\nIf you wish to clarify certain points, add examples or even correct errors, you can follow the steps below:\n\n1. Fork the [repository](https://github.com/mineral-dart/website)\n2. Make your changes\n3. Push your changes and create a pull request\n4. Wait for the review\n5. Once the review is complete, your changes will be merged\n\n### Reporting bugs\n\nBugs are a common occurrence in software development. They can be caused by a variety of factors, such as incorrect\nimplementation, incorrect use of the framework, or even a lack of understanding of the framework.\n\nThe more information you provide, the easier it will be for us to reproduce the bug and correct it, so we recommend that\nyou provide the following information.\n\n- Give context (show `pubspec.yaml`)\n- Description of the bug (copy/paste the error message)\n- Steps to reproduce the bug\n- Expected behavior\n- Actual behavior\n- Screenshots or code snippets (optional)\n\nIf you encounter a bug, you can report it by following these steps:\n\n1. Go to the [issues](https://github.com/mineral-dart/core/issues/new)\n2. Fill in the form with the necessary information\n3. Click on the \"Submit new issue\" button\n4. Wait for the review by the core team\n\n### Adding missing features\n\nThe framework is constantly evolving. New features are added regularly to improve the user experience and make the\nframework more complete.\n\n> [!note]\n> You can find the roadmap [here](https://github.com/orgs/mineral-dart/projects/5/views/2).\n\n#### Installation\n\nWhen we develop the core functionalities, it is preferable to create a blank application simulating a real application\nwith the `core` package at the same folder level.\n\nWe therefore consider the following structure :\n\n```\nâ”œâ”€â”€ root\nâ”‚  â””â”€â”€ bot\nâ”‚  â””â”€â”€ core\nâ”‚  â”‚\nâ”‚  â””â”€â”€ other packages\n```\n\nIn your bot application `pubspec.yaml` file, add the following dependency.\n\n> [!note]\n> In accordance with the [documentation](https://dart.dev/tools/pub/dependencies), using a `path` allows you to develop functionality locally.\n\n:::code-group labels=[pubspec.yaml, bash]\n\n```yaml\ndependencies:\n  mineral:\n    path: ../core\n\n  # Optional\n  mineral_cache:\n    path: ../cache\n```\n\n```bash\ndart pub get\n```\n\n:::","src/content/docs/preface/contribute.mdx","287564844253e71e",true,"governance",{"id":22,"data":24,"body":28,"filePath":29,"digest":30,"deferredRender":21},{"title":25,"description":15,"permalink":22,"order":26,"icon":27},"Governance",2,"lucide:users","# Governance\n\nMineral is an open-source project that thrives on community collaboration and shared vision. Its governance model ensures transparency, inclusivity, and alignment with the project's goals.\n\n---\n\n## Roles and responsibilities\n\n### Authors\n\nParmantier Baptiste (the creator of Mineral) is the author of the project.\n\nThe project author is responsible for the governance, standards and direction of the project.\nIn a nutshell:\n\n- The Project Author decides which new projects should exist under the Mineral banner.\n- The Project Owner is responsible for assigning project members to the various tasks and for transferring tasks to a\n  project member when an existing member retires.\n- It is the author's responsibility to share/document the framework's vision and keep members aligned with it.\n\n### Core team\n\nMembers of the core team are contributors who have made multiple valuable contributions to the project and are now\nrelied upon to both write code directly to the repository and screen the contributions of others.\n\nIn many cases, they are programmers, but it is also possible that they contribute in a different role, for example,\ncommunity engagement.\nTypically, a core team member will focus on a specific aspect of the project and will bring a level of expertise and\nunderstanding that earns them the respect of the community and the project lead.\n\nThe role of core team member is not an official one, it is simply a position that influential members of the community\nwill find themselves in as the project\nlead looks to them for guidance and support.\n\nThe members of the core team have no authority over the general direction of the project. However, they do have the ear\nof the project leader. It is the responsibility of core team members to ensure that each member is aware of the needs of\nthe community and the collective objectives, and to help develop or elicit appropriate contributions to the project.\n\nOften, core team members are given informal control over their specific areas of responsibility and are given the right\nto directly modify certain parts of the source code. In other words, although core team members do not have explicit\ndecision-making power, they will often find that their actions are synonymous with decisions made by the project owner.\n\n### Users\n\nUsers are members of the community who need the project. They are the most important members of the community: without\nthem, the project would have no reason to exist. Anyone can be a user; there are no specific requirements.\n\nUsers are encouraged to participate in the life of the project and the community as much as possible. User contributions\nenable the project team to ensure that it is meeting the needs of those users.\n\nUsers who continue to get involved in the project and its community will become more and more involved. These users can\nthen become contributors, as described above.\n\n---\n\n## Support\n\nAll participants in the community are encouraged to provide support for new users within the project management\ninfrastructure. This support is provided as a way of growing the community. Those seeking support should recognize that\nall support activity within the project is voluntary and is therefore provided as and when time allows.\n\n---\n\n## Branding and Ownership\n\nOnly the projects under the `mineral_` dart pub scope and the Mineral GitHub organization are managed and officially\nsupported by the core team.\n\nAlso, you must not use the Mineral name or logos in a way that could mistakenly imply any official connection with or\nendorsement of Mineral. Any use of the Mineral name or logos in a manner that could cause customer confusion is not\npermitted.\n\nInstead, you must use your own brand name in a way that clearly distinguishes it from Mineral.\n\nAdditionally, you may not use our trademarks for t-shirts, stickers, or other merchandise without explicit written\nconsent.","src/content/docs/preface/governance.mdx","12b39ec61a912da6","welcome",{"id":31,"data":33,"body":37,"filePath":38,"digest":39,"deferredRender":21},{"title":34,"description":15,"permalink":31,"order":35,"icon":36},"Welcome",1,"lucide:sparkles","# Welcome\n\nWelcome to the official documentation for the Mineral framework.\n\nMineral is a backend framework developed in Dart as an abstraction of the official Discord API while integrating an ecosystem to facilitate the development of your Discord applications.\n\nAlthough the Dart language is like a mix between Java and Typescript, we recommend that you experiment with the language itself before you start developing with the Mineral framework.\n\n> [!note]\n> Read the dart documentation [here](https://dart.dev/get-dart).\n\n---\n\n## Philosophy\n\nWe want to focus our efforts on the following areas:\n\n- Developer Experience\n- Performance, security and low power consumption thanks to the Dart language\n- Robustness, modularity and flexibility\n- Complete and intuitive documentation\n- Rich ecosystem\n\n### Our motivations\n\nIn the various programming languages, there are a multitude of alternatives offering an API for interaction with Discord.\nwith Discord, the best known being [discord.js](http://discord.js.org), [eris.js](https://abal.moe/Eris/) or even\n[discord.py](https://discordpy.readthedocs.io/en/stable/) and [jda](https://jda.wiki/introduction/jda/).\n\nWithin the Dart language, there is only one alternative called [Nyxx](https://nyxx.l7ssha.xyz) which, like\ndiscord.js, provides a complete API for developing great Discord bots in a relatively\nfunctional form.\n\n### Librairie vs Framework\n\n#### `Library`\n\nA set of functions or classes that can be used to carry out specific operations. It provides\na set of predefined functions that you can use in your code, so you don't have to write them yourself.\nwriting the functionality yourself.\n\n#### `Framework`\n\nA set of structured software components and libraries that provide a basis on which you can develop your own application.\ndevelop your own application. It defines the structure of your application and provides predefined\npredefined functionality that you can use. Unlike a library, a framework can dictate your application's flow of\ncontrol flow of your application, i.e. it can define the overall architecture of your project.\n\nIf it were simply a question of providing what the wonderful Nyxx library has to offer, the mineral project would have been pointless.\n\nIn fact, we want to professionalise the development of Discord bots within the Dart language by providing a\necosystem for developers.\n\nDrawing on our experience, we want to offer a robust alternative to the traditional event handler that we\nfound on almost every Discord bot project.\n\n### One problem, one solution\n\nWhen designing a Discord bot, it is common to encounter various problems related to the architecture of your\nproject. It is often difficult to structure your code in such a way that it is readable, maintainable and scalable.\nscalable.\n\n---\n\n## Community\n\nThe Mineral community is a place where you can ask questions, share your experiences and meet other developers who use the Mineral framework.\n\nWe encourage you to join the community to get help, share your knowledge and contribute to the project.\n\n- [Discord](https://discord.gg/fH9UQDMZSn)\n- [GitHub](https://github.com/mineral-dart)\n- [Twitter](https://x.com/LeadcodeDev)","src/content/docs/preface/welcome.mdx","c4707039be9e6d1e","blog",["Map",31,42],{"id":31,"data":43,"body":49,"filePath":50,"digest":51,"deferredRender":21},{"title":44,"description":45,"permalink":31,"authors":46,"publishedAt":48},"Discover Explainer","Discover Explainer is a tool that helps you create beautiful, responsive, and accessible web documentation using Astro. It's built with Astro, Tailwind CSS, and TypeScript.",[47],"leadcode_dev","2024-01-01:23:00:00","# Welcome to Explainer\n\nExplainer is a documentation boilerplate designed to help you create beautiful, responsive, and accessible web documentation using [Astro](https://astro.build). This project combines the power of Astro with [Tailwind CSS](https://tailwindcss.com) and [TypeScript](https://www.typescriptlang.org) to provide a smooth development experience.\n\n## Why Explainer?\n\nDocumentation is often overlooked, but it's essential for the adoption and effective use of your project.\nExplainer fills an important gap in the technical documentation ecosystem. While Vue has robust solutions like Vitepress, the React ecosystem suffers from a lack of alternatives that don't depend on Next.js. Most documentation frameworks for React are closely tied to Next.js, which can be limiting for many projects.\n\nThis is where Astro, and by extension Explainer, particularly shines. Astro offers remarkable flexibility by allowing you to integrate any technological component related to your business. You can easily incorporate React, Vue, Svelte components, or even standard web elements according to your specific needs.\n\nThis agnostic approach allows you to create documentation that perfectly aligns with your existing technology stack, without forcing you to adopt a particular ecosystem. Whether you work with React, Vue, or other frameworks, Explainer adapts to your needs rather than the other way around.","src/content/blog/welcome.mdx","f5b3166b4e8226c4","api",["Map",54,55,62,63,71,72,79,80,89,90,98,99,107,108,116,117,124,125,134,135,143,144],"commands",{"id":54,"data":56,"body":59,"filePath":60,"digest":61,"deferredRender":21},{"title":57,"description":15,"permalink":54,"order":16,"icon":58},"Commands","lucide:square-slash","# Commands\n\nSlash commands were implemented with the aim of replacing messages considered as commands with a start-of-line\ncharacter, often defined as a message prefix like `!`.\n\n## Introduction\n\nSlash commands allow users to interact with bots in a more intuitive and structured way, using predefined syntax.\n\nThey make it easier to execute specific commands without having to remember prefixes or complex message formats.\n\nThey were created to replace message-based commands with prefixes, making the user experience smoother and reducing\nsyntax errors.\n\n> [!note]\n> When you change the structure of your commands, please restart your entire application process so that the changes take\n> effect even if the `hmr` is active.\n\n## Valid structure\n\nIn accordance with the Discord API, it is possible to define commands in several formats\nexplained [here](https://discord.com/developers/docs/interactions/application-commands#subcommands-and-subcommand-groups).\n\n### Basic command\n\n```\nâ”œâ”€â”€ command\n```\n\n### Subcommands\n\nAs soon as you define a subcommand, the level 0 command can no longer have any behaviour (handler, options)\n\n```\nâ”œâ”€â”€ command\nâ”‚  â””â”€â”€ subcommand\nâ”‚  â””â”€â”€ subcommand\n```\n\n### Subcommands under many groups\n\n```\nâ”œâ”€â”€ command\nâ”‚  â”œâ”€â”€ groups\nâ”‚  â”‚  â””â”€â”€ subcommand\nâ”‚  â”‚  â””â”€â”€ subcommand\nâ”‚  â””â”€â”€ groups\nâ”‚     â””â”€â”€ subcommand\nâ”‚     â””â”€â”€ subcommand\n```\n\n### Subcommands and groups\n\n```\nâ”œâ”€â”€ command\nâ”‚  â”œâ”€â”€ groups\nâ”‚  â”‚  â””â”€â”€ subcommand\nâ”‚  â”œâ”€â”€ groups\nâ”‚  â”‚  â””â”€â”€ subcommand\nâ”‚  â”‚  â””â”€â”€ subcommand\nâ”‚  â””â”€â”€ subcommand\n```\n\n## Basic command\n\nTo simplify the creation and configuration of commands, we have decided to provide a builder that allows us to reduce\nerrors linked to the data structure requested by Discord's HTTP API.\n\n> [!important]\n> The `name` and `description` properties are mandatory for each command, group or subcommand.\n\nIn the case of a command or subcommand, it is necessary to define a handler that will be used later to respond to the interaction.\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setName('foo')\n  .setDescription('This is a command description')\n  .setHandler((ctx) {\n    final builder = MessageComponentBuilder()\n      ..text('Hello from World');\n\n    ctx.interaction.reply(builder);\n  });\n```\n\n### Context\n\nIf we follow Discord's data structure, we can see that each interaction has a context which\ncan be `server` or `global`.\n\nWhen we develop a command, we prefer to use the context of the guild in which the interaction has been\nexecuted, as this does not have a cache, unlike a `global` command.\n\nSo, by default, each command uses the guild's context and is pushed to Discord when the\n`ServerCreate` event.\n\nYou can change the context of your command using the builder's `setContext` method.\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setContext(CommandContextType.server)\n  .setContext(CommandContextType.global);\n```\n\nDepending on your choice, you will need to adapt your handler to find out the context in which it is being executed.\n\n:::code-group labels=[Without context, Server, Global]\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setHandler((CommandContext ctx) {});\n```\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setContext(CommandContextType.server)\n  .setHandler((ServerCommandContext ctx) {});\n```\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setContext(CommandContextType.global)\n  .setHandler((GlobalCommandContext ctx) {});\n```\n\n:::\n\n### Assign options\n\nCommands can have options that allow you to define arguments for the command.\n\n> [!note]\n> The order in which the options are declared is important because it will affect how your users use the command users.\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .addOption(\n    Option.string(\n      name: 'str',\n      description: 'Your sentence',\n      required: true\n    )\n  );\n```\n\nNow that the options have been defined for your order, you need to modify your handler to take them into account\nin its parameters.\n\nEach option defined must be added to named parameters (the order of declaration is not important)\n\n> [!note]\n> The name of your parameter declared in your handler must be the same as that defined in the `name` key of your option.\n\n```dart\nvoid handle(ctx, {required String str}) { // [!code highlight]\n  print(str);\n}\n\nfinal commandBuilder = CommandBuilder()\n  .setHandler(handle)\n  .addOption(\n    Option.string(\n      name: 'str', // [!code highlight]\n      description: 'Your sentence',\n      required: true\n    )\n  );\n```\n\nIf your parameter is optional, remember to indicate this in the declaration of your handler using the language's\n`null safety` feature.\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setHandler((ctx, {required String? str}) {});\n```\n\n### Options types\n\nBasic types are available to define options for your commands.\n\n:::code-group labels=[String, Integer, Double, Boolean, Attachment]\n\n```dart\nOption.string(\n  name: 'str',\n  description: 'Your sentence',\n  required: true\n);\n```\n\n```dart\nOption.integer(\n  name: 'int',\n  description: 'Your number',\n  required: true\n);\n```\n\n```dart\nOption.double(\n  name: 'int',\n  description: 'Your number',\n  required: true\n);\n```\n\n```dart\nOption.boolean(\n  name: 'bool',\n  description: 'Your boolean',\n  required: true\n);\n```\n\n```dart\nOption.attachment(\n  name: 'attachment',\n  description: 'Your attachment',\n  required: true\n);\n```\n\n:::\n\nMentionable types are available to define options for your commands.\n\n:::code-group labels=[User, Channel, Role, Mentionable]\n\n```dart\nOption.user(\n  name: 'user',\n  description: 'Your user',\n  required :true\n);\n```\n\n```dart\nOption.channel(\n  name: 'channel',\n  description: 'Your channel',\n  required :true\n);\n```\n\n```dart\nOption.role(\n  name: 'role',\n  description: 'Your role',\n  required: true\n);\n```\n\n```dart\nOption.mentionable(\n  name: 'mentionable',\n  description: 'Your mentionable',\n  required: true\n);\n```\n\n:::\n\n### Defining subcommand\n\nSubcommands are commands nested within a top-level command.\n\nWe'll use the same builder to define our level 0 command, to which we'll add subcommands\nusing the `.addSubCommand` method.\n\n> [!note]\n> When you declare subcommands, you can no longer define a handler for the top-level command.\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setName('foo')\n  .setDescription('This is a command description')\n  // [!code --:6]\n  .setHandler((ctx) async {\n    final builder = MessageComponentBuilder()\n      ..text('Hello from World');\n\n    await ctx.interaction.reply(builder);\n  });\n  // [!code ++:11]\n  .addSubCommand((command) {\n    command\n      .setName('bar')\n      .setDescription('This is a subcommand description')\n      .setHandler((ctx) async {\n        final builder = MessageComponentBuilder()\n          ..text('Hello from World');\n\n        await ctx.interaction.reply(builder);\n      });\n  });\n```\n\nAs with a basic command, you can define options for your subcommands in the same way as explained above.\n\n### Command group\n\nGroups are used to group several subcommands together by function.\nWhen you define a group, you must add one or more subcommands to it.\n\n> [!note]\n> When you define a group, you can no longer define a handler for the top-level command.\n\n> [!note]\n> A group cannot have a handler, so a handler must be defined for each subcommand.\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setName('foo')\n  .setDescription('This is a command description')\n  // [!code --:6]\n  .setHandler((ctx) async {\n    final builder = MessageComponentBuilder()\n      ..text('Hello from World');\n\n    await ctx.interaction.reply(builder);\n  });\n  // [!code ++:15]\n  .createGroup((group) {\n    group\n      .setName('group')\n      .setDescription('This is a group description')\n      .addSubCommand((command) {\n        command\n          .setName('bar')\n          .setDescription('This is a subcommand description')\n          .setHandler((ctx) async {\n            final builder = MessageComponentBuilder()\n              ..text('Hello from World');\n\n            await ctx.interaction.reply(builder);\n          });\n      });\n  });\n```\n\n### Registering commands\n\nOnce you have defined your order, you need to declare it in your client for it to be taken into account at Discord.\n\n:::code-group labels=[main.dart]\n\n```dart\nfinal client = ClientBuilder()\n  .setCache(MemoryProvider.new)\n  .build();\n\n// [!code ++:10]\nclient.commands.declare((command) {\n  command\n    ..setName('foo')\n    ..setDescription('This is a command description')\n    ..setHandler((ctx) async {\n      final builder = MessageComponentBuilder()\n        ..text('Hello from World');\n\n      await ctx.interaction.reply(builder);\n    });\n});\n\nawait client.init();\n```\n\n:::\n\n## Translations\n\nTranslations were introduced to allow developers to define text content in several languages.\nIn the case of our commands, they allow messages and arguments to be displayed in the user's language.\n\n> [!important]\n> Translations can only be used for `name` and `description` fields.\n\nWe can apply a translation in two different ways:\n\n- From a `Map\u003CString, String>`.\n- From a `yaml` or `json` file\n\nThe main advantage of using a `Map\u003CString, String>` is the simplicity of defining translations\ndirectly in the code.\n\nHowever, when your application has to manage a multitude of languages, it becomes difficult to define everything in a single\nin a single file without losing readability.\n\nThis is where the 'configuration file' approach comes into play, enabling you to define translations\nin an external file, thereby separating the 'logic' aspect from the 'configuration' aspect.\n\n### Basic command with translations\n\n:::code-group labels=[From Map, From File, Configuration (yaml)]\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setName('foo', translation: Translation({\n    'fr': 'foo',\n    'en': 'foo'\n  }))\n  .setDescription('This is a test command', translation: Translation({\n    'fr': 'Ceci est une commande de test',\n    'en': 'This is a test command'\n  }))\n  .setHandler((ctx) {\n    final builder = MessageComponentBuilder()\n      ..text('Hello from World');\n\n    ctx.interaction.reply(builder);\n  });\n```\n\n```dart\nfinal file = File('src/commands.yaml');\nfinal translation = Translation.file(file: file, key: 'test');\n\nfinal commandBuilder = CommandBuilder()\n  .setName('foo', translation: translation)\n  .setDescription('This is a test command', translation: translation)\n  .setHandler((ctx) async {\n    final builder = MessageComponentBuilder()\n      ..text('Hello from World');\n\n    await ctx.interaction.reply(builder);\n  });\n```\n\n```yaml\ncommands:\n  test:\n    name:\n      fr: bonjour\n      en-GB: hello\n    description:\n      fr: bonjour le monde description\n      en-GB: hello world description\n```\n\n:::\n\n### Command with subcommands and translations\n\n:::code-group labels=[From Map, From File, Configuration (yaml)]\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setName('foo', translation: Translation({\n    'fr': 'foo',\n    'en': 'foo'\n  }))\n  .setDescription('This is a test command', translation: Translation({\n    'fr': 'Ceci est une commande de test',\n    'en': 'This is a test command'\n  }))\n  .addSubCommand((command) {\n    command\n      .setName('sub1', translation: Translation({\n        'fr': 'sub1',\n        'en': 'sub1'\n      }))\n      .setDescription('This is a sub1 command', translation: Translation({\n        'fr': 'Ceci est une sous-commande de test',\n        'en': 'This is a subcommand'\n      }))\n      .setHandler((ctx) async {\n        final builder = MessageComponentBuilder()\n          ..text('Hello from World');\n\n        await ctx.interaction.reply(builder);\n      });\n  });\n```\n\n```dart\nfinal file = File('src/commands.yaml');\nfinal translation = Translation.file(file: file, key: 'test');\nfinal subTranslation = Translation.file(file: file, key: 'test.sub1');\n\nfinal commandBuilder = CommandBuilder()\n  .setName('foo', translation: translation)\n  .setDescription('This is a test command', translation: translation)\n  .addSubCommand((command) {\n    command\n      .setName('sub1', translation: subTranslation)\n      .setDescription('This is a subcommand description', translation: subTranslation)\n      .setHandler((ctx) async {\n        final builder = MessageComponentBuilder()\n          ..text('Hello from World');\n\n        await ctx.interaction.reply(builder);\n      });\n  });\n```\n\n```yaml\ncommands:\n  test:\n    name:\n      fr: bonjour\n      en-GB: hello\n    description:\n      fr: bonjour le monde description\n      en-GB: hello world description\n\n  test.sub1:\n    name:\n      fr: sub1\n      en-GB: sub1\n    description:\n      fr: Ceci est une sous-commande de test\n      en-GB: This is a subcommand\n```\n\n:::\n\n### Command with subcommands, groups and translations\n\nDeclaring translations for a group of subcommands is identical to what we have done so far.\n\n:::code-group labels=[From Map, From File, Configuration (yaml)]\n\n```dart\nfinal commandBuilder = CommandBuilder()\n  .setName('foo', translation: Translation({\n    'fr': 'foo',\n    'en': 'foo'\n  }))\n  .setDescription('This is a test command', translation: Translation({\n    'fr': 'Ceci est une commande de test',\n    'en': 'This is a test command'\n  }))\n  .createGroup((group) {\n    group\n      .setName('group', translation: Translation({\n        'fr': 'group',\n        'en': 'group'\n      }))\n      .setDescription('This is a group command', translation: Translation({\n        'fr': 'Ceci est un groupe de commande de test',\n        'en': 'This is a group test command'\n      }))\n      .addSubCommand((command) {\n        command\n          .setName('sub1', translation: Translation({\n            'fr': 'sub1',\n            'en': 'sub1'\n          }))\n          .setDescription('This is a sub1 command', translation: Translation({\n            'fr': 'Ceci est une sous-commande de test',\n            'en': 'This is a subcommand'\n          }))\n          .setHandler((ctx) async {\n            final builder = MessageComponentBuilder()\n              ..text('Hello from World');\n\n            await ctx.interaction.reply(builder);\n          });\n        });\n  });\n```\n\n```dart\nfinal file = File('src/commands.yaml');\n\nfinal translation = Translation.file(file: file, key: 'test');\nfinal subTranslation = Translation.file(file: file, key: 'test.sub1');\nfinal groupTranslation = Translation.file(file: file, key: 'test.group');\n\nfinal commandBuilder = CommandBuilder()\n  .setName('foo', translation: translation)\n  .setDescription('This is a test command', translation: translation)\n  .createGroup((group) {\n    group\n      .setName('group', translation: groupTranslation)\n      .setDescription('This is a group command', translation: groupTranslation)\n      .addSubCommand((command) {\n        command\n          .setName('sub1', translation: subTranslation)\n          .setDescription('This is a subcommand description', translation: subTranslation)\n          .setHandler((ctx) async {\n            final builder = MessageComponentBuilder()\n              ..text('Hello from World');\n\n            await ctx.interaction.reply(builder);\n          });\n      })\n    );\n```\n\n```yaml\ncommands:\n  test.group:\n    name:\n      fr: groupe\n      en-GB: group\n    description:\n      fr: groupe description\n      en-GB: group description\n\n  test:\n    name:\n      fr: bonjour\n      en-GB: hello\n    description:\n      fr: bonjour le monde description\n      en-GB: hello world description\n\n  test.sub1:\n    name:\n      fr: sub1\n      en-GB: sub1\n    description:\n      fr: Ceci est une sous-commande de test\n      en-GB: This is a subcommand\n```\n\n:::\n\n## Command definition\n\nAs we saw earlier, the declaration of a command is simple at first, but becomes very complex\nas soon as you add several subcommands or groups of subcommands.\n\nTo simplify the declaration of your commands, we've decided to offer you a more modular approach\nthanks to `command definition`.\n\nThe principle of command definition is to define a data structure in a so-called 'configuration' file and then to use this structure to define your commands.\nfile and then use it as the source to build the command (the opposite of what we've been talking about so far).\ndiscussed so far).\n\nThe command is therefore built from a configuration file and can then be overloaded by the builder.\n\n> [!note]\n> The `using` instruction is used to load the configuration file and build the command.\n> This command must be called before any other instruction.\n\n:::code-group labels=[Command, Definition]\n\n```dart\nfinal file = File('config/test_commands.yaml');\n\nfinal definition = CommandDefinition()\n  ..using(file);\n```\n\n```yaml\ncommands:\n  test:\n    name:\n      _default: role\n      fr: role\n      en-GB: role\n    description:\n      _default: Role manager\n      fr: Management des rÃ´les\n      en-GB: Role manager\n```\n\n:::\n\n### Define handlers\n\nWhen you use the command definition approach, you must define a handler for commands or sub-commands.\n\nThe association between your command and its handler is made using the key used to declare a command\nin the definition file.\n\n#### Basic command handlers\n\n:::code-group labels=[Command, Definition]\n\n```dart\nfinal file = File('config/test_commands.yaml');\n\nfinal definition = CommandDefinition()\n  ..using(file)\n  // [!code highlight:3]\n  ..setHandler('test', (ctx) {\n    print('Hello, world!');\n  });\n```\n\n```yaml\ncommands:\n  // [!code highlight]\n  test: ðŸ‘ˆ # Named command key\n    name:\n      _default: role\n      fr: role\n      en-GB: role\n    description:\n      _default: Role manager\n      fr: Management des rÃ´les\n      en-GB: Role manager\n```\n\n:::\n\n> [!note]\n> The key named `_default` is used to define a default value for a given field.\n> It is comparable to the name or description of a command that has no translation.\n\n#### Define subcommand handlers\n\n:::code-group labels=[Command, Definition]\n\n```dart\nfinal file = File('config/test_commands.yaml');\n\nfinal definition = CommandDefinition()\n  ..using(file)\n  ..setHandler('test', (ctx) => print('Hello, world!'))\n  // [!code ++:3]\n  ..setHandler('test.sub1', (ctx) {\n    print('Hello, world!');\n  });\n```\n\n```yaml\ncommands:\n  test:\n    name:\n      _default: role\n      fr: role\n      en-GB: role\n    description:\n      _default: Role manager\n      fr: Management des rÃ´les\n      en-GB: Role manager\n\n  // [!code ++:9]\n  test.add:\n    name:\n      _default: add\n      fr: ajout\n      en-GB: add\n    description:\n      _default: Add given role\n      fr: Ajoute un rÃ´le donnÃ©\n      en-GB: Add given role\n```\n\n:::\n\n### Define groups\n\nAssigning a subcommand to a group simply requires the group to be declared in the definition file and then\nassociated with the subcommand using the `group` key. and then associate it with the subcommand using the `group` key.\n\n> [!note]\n> Only one group can be associated with any one subcommand.\n\n:::code-group labels=[Definition]\n\n```yaml\n// [!code ++:10]\ngroups:\n  myGroup:\n    name:\n      _default: myGroup\n      fr: mon-group\n      en-GB: my-group\n    description:\n      _default: Description of the first group\n      fr: Description de mon groupe\n      en-GB: Description of my group\n\ncommands:\n  test:\n    name:\n      _default: role\n      fr: role\n      en-GB: role\n    description:\n      _default: Role manager\n      fr: Management des rÃ´les\n      en-GB: Role manager\n\n  test.add:\n    // [!code ++]\n    group: myGroup\n    name:\n      _default: add\n      fr: ajout\n      en-GB: add\n    description:\n      _default: Add given role\n      fr: Ajoute un rÃ´le donnÃ©\n      en-GB: Add given role\n```\n\n:::\n\n### Define options\n\nAs with the command structure, options are no exception and must be defined in the\ndefinition file.\n\nOptions are declared in the same way as commands, using a named key.\n\nBasically, an option is constructed as follows.\n\n---\n\n#### Basic types\n\n- `type`: Type de l'option (`string`, `integer`, `double`, `boolean`)\n- `required`: Indique si l'option est obligatoire\n- `name`: Nom de l'option\n- `description`: Description de l'option\n\n:::code-group labels=[Command, Definition]\n\n```dart\nfinal file = File('config/test_commands.yaml');\n\nfinal definition = CommandDefinition()\n  ..using(file)\n  // [!code --]\n  ..setHandler('test', (ctx) {\n  // [!code ++]\n  ..setHandler('test', (ctx, {required String? str}) {\n    print(str);\n  });\n```\n\n```yaml\noptions:\n  - type: string\n    required: false\n    name:\n      _default: str\n      fr: mot\n      en-GB: str\n    description:\n      _default: str description\n      fr: Chaine de caractÃ¨re\n      en-GB: String sentence\n```\n\n:::\n\n---\n\n#### Mentionable types\n\n- `type`: Type de l'option (`user`, `channel`, `role`, `mentionable`)\n- `required`: Indique si l'option est obligatoire\n- `name`: Nom de l'option\n- `description`: Description de l'option\n\n:::code-group labels=[Command, Definition]\n\n```dart\nfinal file = File('config/test_commands.yaml');\n\nfinal definition = CommandDefinition()\n  ..using(file)\n  // [!code --]\n  ..setHandler('test', (ctx) {\n  // [!code ++]\n  ..setHandler('test', (ctx, {required Role role}) {\n    print(str);\n  });\n```\n\n```yaml\noptions:\n  - type: role\n    required: true\n    name:\n      _default: role\n      fr: role\n      en-GB: role\n    description:\n      _default: Target role\n      fr: Role ciblÃ©\n      en-GB: Target role\n```\n\n:::\n\n---\n\n#### Choice types\n\n- `type`: Type de l'option (`choice.string`, `choice.integer`, `choice.double`)\n- `required`: Indique si l'option est obligatoire\n- `name`: Nom de l'option\n- `description`: Description de l'option\n- `choices`: Liste des choix possibles\n- `choices.name`: Nom du choix\n- `choices.value`: Valeur du choix\n\n:::code-group labels=[Command, Definition]\n\n```dart\nfinal file = File('config/test_commands.yaml');\n\nfinal definition = CommandDefinition()\n  ..using(file)\n  // [!code --]\n  ..setHandler('test', (ctx) {\n  // [!code ++]\n  ..setHandler('test', (ctx, {required int language}) {\n    print(str);\n  });\n```\n\n```yaml\noptions:\n  - type: choice.int\n    required: true\n    name:\n      _default: language\n      fr: language\n      en-GB: language\n    description:\n      _default: Choose the best language\n      fr: Choisissez la meilleure langue\n      en-GB: Choose the best language\n    choices:\n      - name: Dart\n        value: 1\n      - name: Python\n        value: 2\n```\n\n:::\n\n### Override command context\n\nIf you want to use a context as a base and then override it according to your use cases, you can\nretrieve the command's `context` in order to access its builder and modify it.\n\n:::code-group labels=[Command, Definition]\n\n```dart\nfinal file = File('config/test_commands.yaml');\n\nfinal definition = CommandDefinition()\n  ..using(file)\n  ..setHandler('test.getValue', (ctx, {required int value}) => print(str))\n  // [!code ++:13]\n  ..context('test.getValue', (command) {\n    command\n      ..setDescription('Get value')\n      ..addOption(\n        ChoiceOption.integer(\n          name: 'value',\n          description: 'This is a value option',\n          required: true,\n          choices: [\n            Choice('First value', 1),\n            Choice('Second value', 2)\n          ]));\n  });\n```\n\n```yaml\ncommands:\n  test:\n    name:\n      _default: role\n      fr: role\n      en-GB: role\n    description:\n      _default: Role manager\n      fr: Management des rÃ´les\n      en-GB: Role manager\n\n  // [!code highlight:9]\n  test.getValue:\n    name:\n      _default: getValue\n      fr: get-value\n      en-GB: get-value\n    description:\n      _default: Get\n      fr: Obtenir une valeur\n      en-GB: Get value\n```\n\n:::\n\n### Registering definition\n\n:::code-group labels=[main.dart]\n\n```dart\nfinal file = File('config/test_commands.yaml');\n\nfinal client = ClientBuilder()\n  .setCache((e) => MemoryProvider())\n  .build();\n\n// [!code ++:7]\nclient.commands.define((command) {\n  command\n    ..using(file)\n    ..setHandler('test.getValue', (ctx, {required int value}) {\n      print(str);\n    });\n}));\n\nawait client.init();\n```\n\n:::\n\n## Command with class approach\n\nAs mentioned above, there are two ways of creating a command.\nSo far, each example has been written using a functional approach.\n\nIt is possible to define a command using an object-oriented approach by using a contract.\n\n```dart\nabstract interface class CommandContract\u003CT extends CommandBuilder> {\n  T build();\n}\n```\n\n### Command with declaration\n\nIn this example, we will use the command definition approach to define our command with `CommandDeclaration` contract.\n\n:::code-group labels=[Command, Contract]\n\n```dart\nfinal class MyCommand implements CommandDeclaration {\n  FutureOr\u003Cvoid> handle(CommandContext ctx, {required int value}) async {\n    final builder = MessageComponentBuilder()\n      ..text('Selected value: $value');\n\n    await ctx.interaction.reply(builder);\n  }\n\n  @override\n  CommandDeclarationBuilder build() {\n    return CommandDeclarationBuilder()\n      ..setName('foo')\n      ..setDescription('This is a command description')\n      ..setHandler(handle)\n      ..addOption(\n        ChoiceOption.integer(\n          name: 'value',\n          description: 'This is a value option',\n          required: true,\n          choices: [\n            Choice('First value', 1),\n            Choice('Second value', 2)\n          ]));\n  }\n}\n```\n\n```dart\nabstract interface class CommandDeclaration implements CommandContract\u003CCommandDeclarationBuilder>{\n  CommandDeclarationBuilder build();\n}\n```\n\n:::\n\n### Command with definition\n\nIn this example, we will use the command definition approach to define our command with `CommandDefinition` contract.\n\n:::code-group labels=[Command, Definition, Contract]\n\n```dart\nfinal class MyCommand implements CommandDefinition {\n  FutureOr\u003Cvoid> addRole(CommandContext ctx, {required Role role}) async {\n    final builder = MessageComponentBuilder()\n      ..text('Role $role has been selected');\n\n    await ctx.interaction.reply(builder);\n  }\n\n  @override\n  CommandDefinitionBuilder build() {\n    return CommandDefinitionBuilder()\n      ..using(File('config/test_commands.yaml'))\n      ..setHandler('role.add', addRole);\n  }\n}\n```\n\n```yaml\ncommands:\n  role:\n    name:\n      _default: role\n      fr: role\n      en-GB: role\n    description:\n      _default: Role manager\n      fr: Management des rÃ´les\n      en-GB: Role manager\n\n  role.add:\n    name:\n      _default: add\n      fr: ajout\n      en-GB: add\n    description:\n      _default: Add given role\n      fr: Ajoute un rÃ´le donnÃ©\n      en-GB: Add given role\n    options:\n      - type: role\n        required: true\n        name:\n          _default: role\n          fr: role\n          en-GB: role\n        description:\n          _default: Target role\n          fr: Role ciblÃ©\n          en-GB: Target role\n```\n\n```dart\nabstract interface class CommandDefinition implements CommandContract\u003CCommandDeclarationBuilder>{\n  CommandDefinitionBuilder build();\n}\n```\n\n:::\n\n### Registering\n\nTo register a command, you need to call the `register` method on your client and pass your command as a parameter.\n\n:::code-group labels=[Registering command]\n\n```dart\nFuture\u003Cvoid> main() async {\n  final client = ClientBuilder()\n    .build();\n\n  // [!code ++]\n  client.register(MyCommand.new) // ðŸ‘ˆ Put your command\n\n  await client.init();\n}\n```\n\n:::","src/content/docs/api/commands.mdx","8d4374736ea7adfb","components",{"id":62,"data":64,"body":68,"filePath":69,"digest":70,"deferredRender":21},{"title":65,"description":15,"permalink":62,"order":66,"icon":67},"Components",4,"lucide:layout-dashboard","# Components\n\nDiscord components are interactive elements such as buttons, drop-down menus and text fields that developers can integrate into messages sent by bots.\n\nThey allow users to interact directly with bots in a more intuitive and dynamic way, improving the user experience by making interactions more engaging and responsive.\n\n## Buttons\n\nButtons in Discord are used to allow users to interact with the interface and perform actions. For example, a button might be used to send a message, join a voice channel, or initiate a game.\n\n> [!note]\n> You can read the entire documentation about buttons [here](https://discord.com/developers/docs/interactions/message-components#buttons).\n\n### Guidelines\n\n- 34 characters max with icon or emoji.\n- 38 characters max without icon or emoji.\n- Keep text concise and to the point.\n- Use clear and easily understandable language. Avoid jargon or overly technical terms.\n- Use verbs that indicate the outcome of the action.\n- Maintain consistency in language and tone across buttons.\n- Anticipate the need for translation, test for expansion or contraction in different languages.\n\n### Types\n\n- `action` : which allow you to create an interaction\n- `link` : which allow you to open a url\n- `premium` : which allow you to buy a premium subscription\n\n---\n\n### Builders\n\nAction buttons are buttons that allow you to interact with the bot.\n\n> [!note]\n> You should define `label` or `emoji` property.\n\n| Property   | Description                        | Required |\n| ---------- | ---------------------------------- | -------- |\n| `label`    | The text displayed on the button.  | No       |\n| `emoji`    | The emoji displayed on the button. | No       |\n| `disabled` | Whether the button is disabled.    | No       |\n\n:::code-group labels=[Primary, Secondary, Success, Danger]\n\n```dart\nfinal primary = ButtonBuilder.primary('customId',\n  label: 'Click me',\n  emoji: PartialEmoji.fromUnicode('ðŸ‘'),\n  disabled: true,\n);\n```\n\n```dart\nfinal secondary = ButtonBuilder.secondary('customId',\n  label: 'Click me',\n  emoji: PartialEmoji.fromUnicode('ðŸš€'),\n  disabled: true,\n);\n```\n\n```dart\nfinal success = ButtonBuilder.success('customId',\n  label: 'Click me',\n  emoji: PartialEmoji.fromUnicode('âœ…'),\n  disabled: true,\n);\n```\n\n```dart\nfinal danger = ButtonBuilder.danger('customId',\n  label: 'Click me',\n  emoji: PartialEmoji.fromUnicode('âŒ'),\n  disabled: true,\n);\n```\n\n:::\n\n---\n\n#### Special buttons\n\nUsed to redirect the user to an external URL without triggering an internal action.\n\n> [!note]\n> You should define `url` property.\n\n:::code-group labels=[Link, Premium]\n\n```dart\nfinal link = ButtonBuilder.link(\n  'https://mineral-foundation.com',\n  label: 'Click me',\n);\n```\n\n```dart\nfinal premium = ButtonBuilder.premium('sku_id');\n```\n\n:::\n\n---\n\n### Sending buttons\n\n> [!important]\n> No more than 5 components can be registered in a single `RowBuilder`.\n\n```dart\nfinal buttons = [\n  MessageButton.primary('primary', label: 'label'),\n  MessageButton.secondary('secondary', label: 'label'),\n  MessageButton.danger('danger', label: 'label'),\n  MessageButton.link('https://google.com', label: 'label'),\n];\n\nfinal builder = MessageComponentBuilder()\n  ..text('# Hello from World')\n  ..buttons(buttons);\n\nawait channel.send(builder);\n```\n\n---\n\n## Dialogs\n\nModals in Discord are interactive pop-up windows that allow users to input information or make specific choices.\n\nThey are used for more complex interactions, such as filling out forms or confirming important actions, enhancing the user experience by providing a richer and more intuitive interface.\n\n> [!note]\n> The `customId` property is mandatory for dialogs.\n\n:::code-group labels=[Dialog builder]\n\n```dart\nfinal text = DialogBuilder(customId)\n  ..setTitle('Test Dialog')\n  ..text(\n    title: 'This is a test dialog',\n    customId: 'title',\n    constraint: DialogFieldConstraint(maxLength: 20))\n  ..paragraph(\n    title: 'This is a test paragraph',\n    customId: 'paragraph',\n    constraint: DialogFieldConstraint(maxLength: 20));\n```\n\n:::\n\n### Sending dialogs\n\n> [!note]\n> Dialogs in Discord can only be used in response to a user interaction.\n\nThis means they must be triggered by a specific user action, such as clicking a button or using a command.\n\nThis restriction ensures that dialogs are always relevant and contextual, thereby enhancing the user experience by providing information or choices at the appropriate time.\n\n```dart\nfinal text = DialogBuilder(customId)\n  ..setTitle('Test Dialog')\n  ..text(\n    title: 'This is a test dialog',\n    customId: 'title',\n    constraint: DialogFieldConstraint(maxLength: 20))\n  ..paragraph(\n    title: 'This is a test paragraph',\n    customId: 'paragraph',\n    constraint: DialogFieldConstraint(maxLength: 20));\n\n// [!code ++]\nawait ctx.interaction.dialog(dialog);\n```\n\n### Handing dialogs\n\nBasiquement, vous pouvez Ã©couter l'Ã©vÃ¨nement de deux maniÃ¨res diffÃ©rentes.\nPar dÃ©faut, l'Ã©vÃ¨nement catch l'ensemble des interactions de type `ServerDialogSubmitEvent`.\n\n:::code-group labels=[Class, Function]\n\n```dart\nfinal class MyDialogEvent extends ServerDialogSubmitEvent {\n  FutureOr\u003Cvoid> handle(ctx, options) {\n    // Handle dialog submit\n  }\n}\n```\n\n```dart\nclient.events.server.dialogSubmit((ctx, options) {\n  // Handle dialog submit\n});\n```\n\n:::\n\nHowever, it is possible to choose just one component to listen to, using its `customId`.\n\n:::code-group labels=[Class, Function]\n\n```dart\nfinal class MyDialogEvent implements ServerDialogSubmitEvent {\n  // [!code ++:2]\n  @override\n  String? get customId => 'customId';\n\n  @override\n  FutureOr\u003Cvoid> handle(ctx, options) {\n    // Handle dialog submit when customId is 'customId'\n  }\n}\n```\n\n```dart\nclient.events.server.dialogSubmit((ctx, options) {\n  // Handle dialog submit when customId is 'customId'\n// [!code --]\n});\n// [!code ++]\n}, customId: 'customId');\n```\n\n:::\n\n---\n\n## Select menus\n\nSelection menus in Discord are interactive elements that allow users to choose from a list of predefined options.\n\nThey are used for more complex interactions where multiple choices are possible, enhancing the user experience by providing a richer, more intuitive interface.\n\n### Execution context\n\nThe action resulting from the user's choice is carried out in a certain interaction context which influences the information available to the user.\n\nThere are currently 2 types of interaction context:\n\n- `ServerSelectContext` : Interaction context for servers.\n- `PrivateSelectContext` : Interaction context for private messages.\n\n### Text menu\n\n:::code-group labels=[Select Menu, Function handling, Class handling]\n\n```dart\nfinal helloEmoji = PartialEmoji.fromUnicode('ðŸ‘‹');\nfinal worldEmoji = PartialEmoji.fromUnicode('ðŸŒ');\n\n// [!code ++:4]\nfinal selectMenu = MessageMenu.text('text', [\n  SelectMenuOption(label: 'label 1', value: 'value 1'),\n  SelectMenuOption(label: 'label 2', value: 'value 2'),\n]);\n\nfinal builder = MessageComponentBuilder()\n  ..text('# Hello from World')\n  // [!code ++:1]\n  ..selectMenu(selectMenu);\n\n// [!code ++]\nawait channel.send(builder);\n```\n\n```dart\nclient.events.server.selectText((ctx, values) async {\n  final builder = MessageComponentBuilder()\n    ..text('Find ${values.length} channels ($channelNames)');\n\n  await ctx.interaction.reply(builder: builder, ephemeral: true);\n}, customId: 'customId');\n```\n\n```dart\n// âš ï¸ Don't forget to register the event in your main file\nfinal class MyTextSelect extends ServerTextSelectEvent {\n  @override\n  String get customId => 'customId';\n\n  @override\n  FutureOr\u003Cvoid> handle(ServerSelectContext ctx, List\u003CString> values) async {\n    final builder = MessageComponentBuilder()\n      ..text('Find ${values.length} channels ($channelNames)');\n\n    await ctx.interaction.reply(builder: builder, ephemeral: true);\n  }\n}\n```\n\n:::\n\n### Channel menu\n\n:::code-group labels=[Select Menu, Function handling, Class handling]\n\n```dart\n// [!code ++:3]\nfinal channelSelectMenu = MessageMenu.channel('channel',\n  channelTypes: [ChannelType.guildText],\n  defaultValues: [Snowflake.parse('1322554770057068636')]);\n\nfinal builder = MessageComponentBuilder()\n  ..text('# Hello from World')\n  // [!code ++]\n  ..selectMenu(channelSelectMenu));\n\n// [!code ++]\nawait channel.send(builder);\n```\n\n```dart\nclient.events.server.selectText((ctx, channels) async {\n  final channelNames = channels.map((channel) => channel.name);\n\n  final builder = MessageComponentBuilder()\n    ..text('${values.length} channels ($channelNames)');\n\n  await ctx.interaction.reply(builder: builder, ephemeral: true);\n}, customId: 'customId');\n```\n\n```dart\n// âš ï¸ Don't forget to register the event in your main file\nfinal class MyChannelSelect extends ServerChannelSelectEvent {\n  @override\n  String get customId => 'customId';\n\n  @override\n  FutureOr\u003Cvoid> handle(ServerSelectContext ctx, List\u003CServerChannel> channels) async {\n    final builder = MessageComponentBuilder()\n      ..text('Find ${values.length} channels ($channelNames)');\n\n    await ctx.interaction.reply(builder: builder, ephemeral: true);\n  }\n}\n```\n\n:::","src/content/docs/api/components.mdx","cc886eac96ca13eb","cli",{"id":71,"data":73,"body":76,"filePath":77,"digest":78,"deferredRender":21},{"title":74,"description":15,"permalink":71,"order":66,"icon":75},"Command Line Interface","lucide:terminal","# Command Line Interface\n\nThe Command Line Interface (CLI) is a powerful tool that allows users to interact with their computer systems and\nsoftware applications through text-based commands.\n\n---\n\n## Installation\n\n> [!note]\n> Before start, please make sure you have the Dart SDK installed on your machine.\n\n> [!note]\n> You can find the current version of the Mineral CLI [here](https://pub.dev/packages/mineral_cli).\n\nTo install the Mineral CLI, run the following command:\n\n:::code-group auto\n```bash\ndart pub global activate mineral_cli [version]\n```\n:::\n\nNow you can use it like this:\n\n:::code-group auto\n```bash\nmineral help\n```\n:::\n\n```\nWelcome to Mineral CLI !\nWork seamlessly with Mineral from the command line.\n\nUSAGE:\n  mineral \u003Ccommand> \u003Csubcommand> [flags]\n\nCORE COMMANDS\n  create           Create a new project\n  help             Display the help message\n\nMAKE COMMANDS\n  make:event       Create a new event class\n  make:command     Create a new command class\n```\n\nThe CLI is used in two different ways depending on the location and context in which it is used.\n\n| Context | Description |\n|---------|-------------|\n| `Global` | This is the default context, and is used when the CLI is requested from anywhere in the system outside of a Mineral project. |\n| `Project` | Within a Mineral project, the CLI is called within the context of your application. create your own commands using your project's environment variables. |\n\n---\n\n## Core commands\n\nThe basic commands are those available by default in the CLI.\n\n### Help\n\nThe `help` command displays the list of commands available in the CLI.\n\n```\nWelcome to Mineral CLI !\nWork seamlessly with Mineral from the command line.\n\nUSAGE:\n  mineral \u003Ccommand> \u003Csubcommand> [flags]\n\nCORE COMMANDS\n  create           Create a new project\n  help             Display the help message\n\nMAKE COMMANDS\n  make:event       Create a new event class\n  make:command     Create a new command class\n  make:provider    Create a new provider entrypoint\n  make:state       Create a new global state\n```\n\nIt is important to note that when you create commands injected into the CLI, they will automatically appear in this help\nmenu. automatically appear in this help menu.\n\n---\n\n### Create project\n\nThe `create` command is used to create a new Mineral project.\n\n:::code-group auto\n```bash\nmineral create [project_name]\n```\n:::\n\n| Properties | Description |\n|------------|-------------|\n| `project_name` | The name of the project to create. |\n| `token` | When the command is run, you will be asked to enter your application's token in order to pre-populate your environment file. |\n| `hmr` | HMR (Hot Module Replacement) is a feature that automatically reloads your business code without having to restart having to restart your project. |\n| `preset` | You can then choose the skeleton of your project's software architecture in the form of an installation preset. |\n\n> [!note]\n> When the token is registered, it is processed securely and will never be shared outside your project.\n\nYou can then choose the skeleton of your project's software architecture in the form of an installation preset.\nAt present, 3 presets are available :\n- `Slim` : A minimalist project with a minimal basic structure.\n- `Basic` : A preset based on an architecture that groups components by type.\n- `Hexagonal` : A preset based on an architecture that groups components by domain.\n\n> [!important]\n> See the [dedicated section](/docs/guide/structure) for more information on the structure of a project.\n\n---\n\n### Make event\n\nThe `make:event` command is used to create a new event.\n\n:::code-group auto\n```bash\nmineral make:event [filename]\n```\n:::\n\n> [!note]\n> If you do not provide the name of your file, you will be asked to define it later.\n\nThe command will ask you to choose an event from among those available in the current version of the `core` used in your\nproject.\n\n---\n\n### Make command\n\nThe `make:command` command is used to create a new command.\n\n:::code-group auto\n```bash\nmineral make:command [filename]\n```\n:::\n\n> [!note]\n> If you do not provide the name of your file, you will be asked to define it later.\n\nThe command will offer you a choice of two types of command :\n- Declaration\n- Definition\n\nFor each of the cases presented, you will be asked to complete your order by means of a question and answer game.\n\nYou can find more information about orders in the [dedicated section](/docs/fundamentals/commands).\n\n---\n\n### Make provider\n\nThe `make:provider` command is used to create a new provider.\n\n:::code-group auto\n```bash\nmineral make:provider [name]\n```\n:::\n\n> [!note]\n> If you do not provide the name of your file, you will be asked to define it later.\n\nSee the [dedicated section](/docs/fundamentals/providers) for more information on providers.\n\n---\n\n### Make state\n\nThe `make:state` command is used to create a new state.\n\n:::code-group auto\n```bash\nmineral make:state [name]\n```\n:::\n\n> [!note]\n> If you do not provide the name of your file, you will be asked to define it later.\n\nSee the [dedicated section](/docs/fundamentals/global-states) for more information on shared states.\n\n## Make your own commands\n\nYou can also create your own commands to simplify or automate certain processes.\n\nThe procedure explained below is valid when you want to create commands for your project but also as part of packages\nregistered on the `dart pub` registry.\n\n> [!note]\n> Some packages may have their own commands.\n> Simply installing the package will automatically inject the commands into the CLI __without any additional action__.\n\nTo collect choices from the user of your order, we recommend that you use\nthe [`commander_ui`](https://github.com/LeadcodeDev/commander) library, which will enable you to create interactive\ninterfaces within CLi and the [`mansion`](https://pub.dev/packages/mansion) package to make colored output.\n\n---\n\n### Structure\n\nWe recommend that you structure your commands according to the structure recommended in the official documentation.\n\nWe will use a `bin` folder for this purpose, but you are free to choose the location.\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\n// [!code ++:3]\nâ”œâ”€â”€ cli\nâ”‚  â”œâ”€â”€ my_command.dart\nâ”‚  â””â”€â”€ my_command2.dart\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\n---\n\n### Declaration\n\nDeclaring a command is an important step, as it indicates its existence within the CLI.\n\nFollowing the example of Flutter, add a new `mineral` key to the `pubspec.yaml` file in your project.\nwhich will contain a list of commands.\n\n:::code-group labels=[pubspec.yaml]\n```yaml\nname: my_application\ndescription: A simple mineral application\n\n# [!code ++:5]\nmineral:\n  commands:\n    - name: my_command\n      description: My first command\n      entrypoint: cli/my_command.dart\n\nenvironment:\ndependencies:\ndev_dependencies:\n```\n:::\n\nThe use of a `yaml` file is mandatory because the CLI invokes the targeted command through the spawn of a new `Process`.\n\n---\n\n### Entrypoint\n\nThe input file for your command is the file that will be invoked by the CLI.\nIt is defined when mapping your commands in the `pubspec.yaml` file.\n\n:::code-group labels=[pubspec.yaml]\n```yaml\nmineral:\n  commands:\n    - name: my_command\n      description: My first command\n      # [!code highlight]\n      entrypoint: cli/my_command.dart\n```\n:::\n\nThe sine qua non condition for this invocation to work properly is the presence of a hand' function in the file containing your command.\n\nWe can think of each command as a program in its own right which can itself instantiate various services used within\nyour Mineral application in the same way as when you start it.\n\n> [!note]\n> A command has no `Mineral` reference instance, so if you want to use components from the framework, you'll have to instantiate them yourself.\n\nFor example, you can use Mineral's environment service to retrieve environment variables environment variables within\nyour main application.\n\n:::code-group labels=[cli/my_command.dart, .env]\n```dart\nimport 'package:mineral/api.dart';\nimport 'package:mineral/services.dart';\n\nvoid main() {\n  final token = env.get(AppEnv.token);\n  print('Your token is $token');\n}\n```\n```dotenv\nDART_ENV=development\nTOKEN=your_token\nDISCORD_REST_API_VERSION=10\nDISCORD_WS_VERSION=10\nINTENT=3276799\nLOG_LEVEL=TRACE\n```\n:::\n\n---\n\n### Help displaying\n\n> [!note]\n> You can sort your orders by name.\n\nIf your command is called `migration:run` or `migration:rollback`, it will be filed in the dedicated migration section.\n\n```\n...\nMIGRATION COMMANDS\n  migration:run          Run SQL database migrations\n  migration:rollback     Rollback SQL database migrations\n...\n```","src/content/docs/api/cli.mdx","18ce3dabea6f2af3","container",{"id":79,"data":81,"body":86,"filePath":87,"digest":88,"deferredRender":21},{"title":82,"description":83,"permalink":79,"order":84,"icon":85},"Service container","Service container is a container that holds the services for the application.",10,"lucide:box","# Service container\n\nIoC is a concept that allows services to be defined in a container and then used in the rest of the application via a\nsingle instance.\napplication using a single instance.\n\nIt improves the modularity and reusability of the code, as well as its testability.\n\n---\n\n## Introduction\n\nInversion of Control (`IoC`) is a design principle used in software development to increase the modularity and flexibility\nof code. It involves delegating the control of certain aspects of a program, such as the creation and management of\nobjects, to a container or framework.\n\nThis approach allows developers to focus on the business logic of their application while the IoC container handles the\ninstantiation and lifecycle of dependencies.\n\n### Benefits\n\n- **Decoupling :** IoC reduces the tight coupling between components, making the system more adaptable to changes. Ease of Maintenance: With a clear separation of concerns, maintaining and updating the code becomes more straightforward.\n- **Testability :** Dependencies can be injected, making it easier to write unit tests and achieve higher test coverage.\n- **Flexibility :** It provides the flexibility to change implementations without modifying the dependent code, facilitating easier updates and maintenance.\n\n## How it works\n\nIn your applications, it is common to want to share services between several components such as\nrepositories, services, configurations, etc.\n\nIoC simplifies the task by allowing you to define these services in a central container and use them in the rest of the application via a single instance.\nthe rest of the application via a single instance.\n\n> [!note]\n> Follow [this link](https://refactoring.guru/design-patterns/singleton) to learn more about `Singleton` pattern.\n\n## Basic usage\n\nWithin the Mineral framework, we have decided not to use code generation (judging a lack of\ncontrol), which means writing additional code in order to make full use of IoC.\n\nBasically, an IoC involving service injection consists of two stages.\n\n1. Creation of a service in the form of a class\n2. Call of the service by a consumer. If the service exists, it is injected, otherwise it is instantiated and then injected.\n\n## Mineral usage\n\nIn the Dart language, it is impossible to locate the services called without using reflection,\nbut using it means that you can no longer compile the application to `jit`, `aot`, `exe`... because this reflection only\nonly works within the Dart VM.\n\nAs it is, we have to inject our services ourselves.\n\n> [!note]\n> With the announcement and development of `macros` in Dart, it is possible that we will be able to automate this task of\n> instantiation task.\n\n### Create a service\n\n:::code-group labels=[service.dart]\n```dart\nfinal class MyClass {\n  void sayHello() => print('Hello World');\n}\n```\n:::\n\n### Register and resolve the service\n\nThere are two ways of registering our service with the IoC :\n\n1. bind: registers a service without returning it.\n2. make: registers a service and returns it.\n\n> [!warning]\n> It is not possible to retrieve a service not previously instantiated in the IoC.\n\n:::code-group labels=[binding, making]\n```dart\nvoid main() {\n  ioc.bind(MyClass.new);\n\n  final service = ioc.resolve\u003CMyClass>();\n  service.sayHello();\n}\n```\n\n```dart\nvoid main() {\n  final service = ioc.make(MyClass.new);\n  service.sayHello();\n}\n```\n:::\n\nIn order to abstract a service, it is also possible to give an `interface` instead of a direct implementation.\n\n:::code-group labels=[main.dart,service.dart, contract]\n```dart\nvoid main() {\n   // [!code --:2]\n  ioc.bind(MyClass.new);\n  final service = ioc.resolve\u003CMyClass>();\n\n // [!code ++:2]\n  ioc.bind\u003CMyClassContract>(MyClass.new);\n  final service = ioc.resolve\u003CMyClassContract>();\n\n  service.sayHello();\n}\n```\n```dart\nfinal class MyClass implements MyClassContract {\n  void sayHello() => print('Hello World');\n}\n```\n```dart\nabstract interface class MyClassContract {\n  void sayHello();\n}\n```\n:::","src/content/docs/api/container.mdx","6c5bb667dd109163","global-states",{"id":89,"data":91,"body":95,"filePath":96,"digest":97,"deferredRender":21},{"title":92,"description":15,"permalink":89,"order":93,"icon":94},"Global States",6,"lucide:brain","# Global States\n\nIt is sometimes difficult to share data through your applications, the Mineral framework offers an essential component\nto overcome this problem.\n\n---\n\n## Introduction\n\nUnder the Node runtime with the Javascript language, you are advised when you start developing discord applications to\ndevelop your entire application within a single file, your index.js.\n\n:::code-group labels=[index.js]\n```js\nimport { Client, GatewayIntentBits } from 'discord.js'\n\nconst foo = 'bar'\nconst client = Client({ intents: [GatewayIntentBits.Guilds] })\n\nclient.once('ready', () => {\n  console.log(`${foo} is ready !`)\n});\n\nclient.on('messageCreate', () => {\n  console.log(`${foo} is ready !`)\n});\n\nclient.login('...')\n```\n:::\n\nSo each of your listeners can access every variable defined within it, but this practice is bad because your application\nwill lose a lot of scalability and maintainability. This benefit is lost when we decide to decompose our application\nfollowing a business logic.\n\nIn order to overcome this lack of accessibility, the Mineral framework allows you to design shared data throughout your\napplication through a very important notion: shared states.\n\nThese shared states are represented as classes instantiated within your main.dart file or modules and will be directly\ninjected within the instance of your events, commands or context menus.\n\n---\n\n## Create global state\n\nFirst, we will execute a command from the CLI of the Mineral framework.\n\n:::code-group auto\n```bash\nmineral make:state \u003Cname>\n```\n:::\n\nThis command will create a new file in the target directory of your project. This file will contain a class that will\nbe used to store your shared data.\n\n:::code-group labels=[counter_state.dart, contract]\n```dart\nfinal class CounterState implements GlobalState\u003Cint> {\n  @override\n  int state = 0;\n\n  @override\n  void increment() => state++;\n\n  @override\n  void decrement() => state--;\n}\n```\n```dart\nabstract interface class GlobalState\u003CT> implements Listenable {\n  T get state;\n}\n```\n:::\n\n> [!note]\n> Our `T state` is seen as a `getter` and not a property, this prevents redefining the value of the variable from outside the class.\n\nOnce your blind is created, we will add it to the `main.dart` file or to your module.\n\n:::code-group labels=[main.dart]\n```dart\nvoid main(_, port) async {\n  final client = Client()\n    .setHmrDevPort(port)\n    .build();\n\n  client.register(CounterState.new);\n}\n```\n:::\n\n## Usage with abstract contract\n\n:::code-group labels=[counter_state.dart, contract]\n\n```dart\nfinal class CounterState implements GlobalState\u003Cint> { // [!code --]\nfinal class CounterState implements CounterStateContract { // [!code ++]\n  @override\n  int state = 0;\n\n  @override\n  void increment() => state++;\n\n  @override\n  void decrement() => state--;\n}\n```\n```dart\nabstract interface class CounterStateContract implements GlobalState\u003Cint> {\n  void increment();\n  void decrement();\n}\n```\n:::\n\nOnce your contract is implemented, we can override the state binding with generic.\n\n:::code-group labels=[main.dart]\n```dart\nvoid main(_, port) async {\n  final client = Client()\n    .setHmrDevPort(port)\n    .build();\n\n  client.register(CounterState.new); // [!code --]\n  client.register\u003CCounterStateContract>(CounterState.new); // [!code ++]\n}\n```\n:::\n\n---\n\n## Retrieve global state\n\nIn the followed section, we consider that the state is a counter with `CounterStateContract` named binding.\n\nTo retrieve a global state, we provide an `State` mixin that allows you to inject states into your class for easy\naccess.\n\n:::code-group labels=[my_event.dart]\n```dart\nfinal class MyEvent extends MessageCreateEvent { // [!code --]\nfinal class MyEvent extends MessageCreateEvent with State { // [!code ++]\n  @override\n  Future\u003Cvoid> handle(ServerMessage message) async {\n    // [!code ++:2]\n    final counter = state.read\u003CCounterStateContract>();\n    counter.increment();\n\n    print('Counter value: ${counter.state}'); // [!code ++]\n  }\n}\n```\n:::","src/content/docs/api/global-states.mdx","b3623a0fc86c7410","interactive-components",{"id":98,"data":100,"body":104,"filePath":105,"digest":106,"deferredRender":21},{"title":101,"description":15,"permalink":98,"order":102,"icon":103},"Interactive Components",5,"lucide:mouse-pointer-2","# Interactive Components","src/content/docs/api/interactive-components.mdx","f5074ca845ff9800","event",{"id":107,"data":109,"body":113,"filePath":114,"digest":115,"deferredRender":21},{"title":110,"description":15,"permalink":111,"order":26,"icon":112},"Events","events","lucide:bell","# Events","src/content/docs/api/event.mdx","084a5b1dae0ee378","environment-variables",{"id":116,"data":118,"body":121,"filePath":122,"digest":123,"deferredRender":21},{"title":119,"description":15,"permalink":116,"order":35,"icon":120},"Environment variables","lucide:key-round","# Environment variables\n\nEnvironment variables serve the purpose of storing secrets like the database password, the app secret, or an API key outside of your application codebase.\n\nIn addition, environment variables can be used to obtain different configurations depending on the environment, such as the use of a secret to use an API or database identifiers.\n\n---\n\n## Introduction\nNormally, environment variables are accessible via Dart's `Platform` class, but this is said to be immutable, so we can't add data relating to our application to it.\n\nSo we're providing an `Environment` class to access the various environment variables in your application.\n\n> [!important]\n> Environment variable management is deported to an agnostic package [`env_guard`](https://pub.dev/packages/env_guard) created for this purpose and which can be used in any Dart or Flutter project.\n\n\nThe environment management is done from the `Env` class which is made available from the `env_guard` package.\n\n:::code-group labels=[env.dart]\n```dart\nabstract interface class Env {\n  T get\u003CT>(String key, {T? defaultValue});\n\n  Map\u003CString, dynamic> validate(\n    Map\u003CString, EnvSchema> schema,\n    Map\u003CString, dynamic> data,\n  );\n\n  void define(\n    Map\u003CString, EnvSchema> schema, {\n    Directory? root,\n    bool includeDartEnv = true,\n  });\n\n  void defineOf\u003CT extends DefineEnvironment>(T Function() source, { \n    Directory? root, \n    bool includeDartEnv = true \n  });\n}\n```\n:::\n\nWe recommend that you use an `.env` environment file to store your environment variables as far as possible, although you can inject your variables using your CLI.\n\n:::code-group auto\n```bash\ndart run src/main.dart --dart-define=MY_VARIABLE=\"Hello World\"\n```\n:::\n\n> [!note]\n> See more in Dart's [documentation](https://dart.dev/guides/environment-declarations).\n\n\n:::code-group labels=[.env, main.dart, schema.dart]\n```dotenv\nDART_ENV=development\nTOKEN=your_token\nDISCORD_REST_API_VERSION=10\nDISCORD_WS_VERSION=10\nINTENT=3276799\nLOG_LEVEL=TRACE\n```\n```dart\nvoid main() {\n  env.defineOf(AppEnv.new);\n}\n```\n```dart\nfinal class AppEnv implements DefineEnvironment {\n  static final String host = 'HOST';\n  static final String port = 'PORT';\n  static final String uri = 'URI';\n\n  @override\n  final Map\u003CString, EnvSchema> schema = {\n    host: env.string().optional(),\n    port: env.number().integer(),\n    uri: env.string(),\n  };\n}\n```\n:::","src/content/docs/api/environment-variables.mdx","c03df1459a03abfd","hmr",{"id":124,"data":126,"body":131,"filePath":132,"digest":133,"deferredRender":21},{"title":127,"description":128,"permalink":124,"order":129,"icon":130},"Hot Module Replacement","Hot Module Replacement is a feature that allows you to replace a module without reloading the page.",11,"lucide:zap","# Hot Module Reloading\n\nWithin the Mineral ecosystem, HMR (Hot Module Reloading) is a feature that automatically reloads your business code\nwithout having to restart your project or recreate a connection to Discord's Websocket API.\n\n> [!important]\n> The integration of HMR uses an agnostic package named [`hmr`](https://pub.dev/packages/hmr).\n\n---\n\n## Introduction\n\nThis feature is particularly useful when you are developing your application and want to see the changes you make without having to restart your project.\n\nIt is important to note that the HMR only reloads the contents of your root project's (based on the following glob pattern `**.dart`) without any external dependencies.\n\n---\n\n## How it works\n\nWhen you start the application from the `dart run bin/main.dart` command, it will perform three distinct actions :\n\n1. Initialise the connection with Discord's Websocket\n2. Listen for incoming events\n3. Start the business part of your application into an `Isolate`\n\n---\n\n## Developer actions\n\nWhen you develop your application and perform one of the following actions (creating, modifying, or saving a file), a chain of actions will be triggered.\n\n### Compile\n\nWhen a change is detected in your Dart project, the system triggers a recompilation of the affected files. This process uses Dart's kernel compilation, which transforms your source code into an intermediate representation known as the `kernel`.\n\nThe kernel format is optimized for **fast incremental** compilation and **efficient execution** in Dart's runtime environments.\n\n**Advantages and Benefits of Kernel Compilation:**\n\n- **Speed:** Kernel compilation is significantly faster than full compilation, allowing for near-instantaneous reloads during development. Only the changed files and their dependencies are recompiled, reducing wait times.\n\n- **Incremental Updates:** The kernel format supports incremental compilation, meaning you don't need to rebuild your entire project for every change.\n\n- **Resource Efficiency:** By compiling only the necessary parts of your project, kernel compilation conserves system resources and minimizes CPU usage.\n\n- **Consistency:** The kernel intermediate representation ensures that the runtime environment receives a consistent and validated version of your code, reducing the risk of runtime errors due to incomplete reloads.\n\nOverall, kernel compilation is a key enabler for Hot Module Reloading in Dart, providing the foundation for efficient, reliable, and rapid development cycles.\n\n### Killing and restarting\n\nOnce our application has been compiled into `kernel` format, the system deletes the existing child Isolate, which executes the developer's business code. Then, a new Isolate is created from the `.dill` file generated during compilation.\n\nThis `.dill` file represents the result of the intermediate compilation and contains all the code necessary to execute the business part of the application. It is stored in a temporary directory, which ensures that the resources used are automatically cleaned up when the main application is shut down.\n\nThis mechanism allows the business code to be reloaded quickly and efficiently without interrupting the main connection to Discord or restarting the entire process.\n\n> [!note]\n> See the [persistence](#persistence-through-reloading) section to learn more about how the system handles persistence.\n\nThus, each change to the source code triggers a recompilation, followed by the destruction and recreation of the business Isolate, ensuring that the latest changes are taken into account immediately.\n\n---\n\n## Persistence through reloading\n\nAt this stage, we have the expected behaviour of reloading the entire business application when a file is saved.\n\nThe problem we now face is the loss of the application's state each time it is reloaded.\nThis state is as much the responsibility of the memory, if the application uses it as a cache, as of the synchronisation of the local state (application) with the remote state (Discord) of our data.\n\nIn our case, when HMR is enabled (i.e., in development mode), all packets entering the application from Discord are intercepted by the main process. The main process listens for these events and dynamically redistributes them to the \"business\" isolate that executes the application code.\n\nThis mechanism ensures that, even when the business code is reloaded after a change, the isolate receives all Discord events as in the production environment. Thus, execution remains transparent and consistent between development and production modes, without loss of information or interruption of synchronisation with Discord.\n\n#### No reconnection to Discord WebSocket\n\nThanks to the separation between the main process (which manages the connection to the WebSocket) and the business isolate, reloading the code does not require resetting the connection to Discord. This avoids reaching the strict limit of 1,000 reconnections per day imposed by Discord.\n\n> [!note]\n> See the Discord [documentation](https://discord.com/developers/docs/events/gateway#identifying) on reconnection limits\n\n#### Drastic reduction in rate-limit cases\n\nBy avoiding unnecessary reconnections, the risk of being temporarily blocked by Discord due to exceeding the quota is greatly reduced. This allows for peaceful development without fear of being penalised by the rate-limit system.\n\n#### Transparent use for the developer\n\nThe developer does not have to worry about managing the connection or reloading events. Everything is automated, making the development experience smooth and uninterrupted, even when making frequent changes to the business code.\n\n---\n\n## Usages\n\nIn your `main.dart` file, add the retrieval of the Isolate port to the `main` function parameters, then transfer them to your `ClientBuilder` instance using the `setHmrDevPort` method.\n\n:::code-group labels=[main.dart]\n\n```dart\nFuture\u003Cvoid> main() async { // [!code --]\nFuture\u003Cvoid> main(_, port) async { // [!code ++]\n  final client = ClientBuilder()\n      .setHmrDevPort(port) // [!code ++]\n      .build();\n\n  await client.init();\n}\n```\n\n:::\n\nThe use of HMR is based on two main components:\n\n#### Watcher\n\nThe Watcher monitors changes to project files, automatically detecting creations, deletions, or modifications. It applies filters and optimisations (such as debounce) to respond only to relevant changes, ensuring efficient and responsive monitoring of the source code.\n\n#### Runner\n\nThe Runner takes over as soon as a change is detected: it compiles the modified code into kernel format, deletes the existing Isolate, and starts a new Isolate with the updated code. This process ensures that the application always runs the latest version of the code without interrupting the main connection or losing critical state.\n\n:::code-group labels=[watcher.dart]\n\n```dart\nfinal watcher = Watcher(\n  onStart: () => print('Started'),\n  onFileChange: (int eventType, File file) => print('File changed'),\n  middlewares: [\n    IgnoreMiddleware(['~', '.dart_tool', '.git', '.idea', '.vscode']),\n    IncludeMiddleware([Glob('**.dart'), ..._watchedFiles]),\n    DebounceMiddleware(Duration(milliseconds: 50), dateTime),\n  ]\n);\n\nwatcher.watch();\n```\n\n:::\n\n---\n\n### Excludes\n\nExclusion of certain files or folders from the monitoring process.\n\n:::code-group labels=[watcher.dart]\n\n```dart\nfinal watcher = Watcher(\n  onStart: () => print('Started'),\n  onFileChange: (int eventType, File file) => print('File changed'),\n  middlewares: [\n    IgnoreMiddleware(['~', '.dart_tool', '.git', '.idea', '.vscode']), // [!code highlight]\n    IncludeMiddleware([Glob('**.dart'), ..._watchedFiles]),\n    DebounceMiddleware(Duration(milliseconds: 50), dateTime),\n  ]\n);\n```\n\n:::\n\nWhen the Watcher detects a change in the project, it first applies this middleware to ignore specified paths (e.g., `~`, `.dart_tool`, `.git`, `.idea`, `.vscode`). This prevents changes in temporary, configuration, or version control folders from unnecessarily triggering code reloading.\n\n---\n\n### Includes\n\nSpecifies exactly which files should be taken into account by the Watcher when detecting changes.\n\n:::code-group labels=[watcher.dart]\n\n```dart\nfinal watcher = Watcher(\n  onStart: () => print('Started'),\n  onFileChange: (int eventType, File file) => print('File changed'),\n  middlewares: [\n    IgnoreMiddleware(['~', '.dart_tool', '.git', '.idea', '.vscode']),\n    IncludeMiddleware([Glob('**.dart'), ..._watchedFiles]), // [!code highlight]\n    DebounceMiddleware(Duration(milliseconds: 50), dateTime),\n  ]\n);\n```\n\n:::\n\nThis middleware filters events so that it only reacts to changes affecting files matching the given patterns (e.g., all Dart files via `Glob('**.dart')`). This prevents irrelevant changes (such as configuration files or static resources) from triggering code reloading.\n\nIn some cases, it is necessary to be able to listen to other files that play an important role in the project.\n\nIn a hypothetical case, we would like to listen for changes to a configuration file written in YAML format.\n\n:::code-group labels=[main.dart, configuration.yaml]\n\n```dart\nvoid main(_, port) async {\n  final configuration = await File('configuration.yaml').readAsYaml();\n  print(configuration['sentence']);\n\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .watch([Glob('**.yaml')]) // [!code ++]\n    .build();\n```\n\n```yaml\nsentence: Hello from Mineral\n```\n\n:::","src/content/docs/api/hmr.mdx","41003f87107be782","placeholders",{"id":134,"data":136,"body":140,"filePath":141,"digest":142,"deferredRender":21},{"title":137,"description":15,"permalink":134,"order":138,"icon":139},"Placeholders",7,"lucide:hash","# Placeholders\n\nPlaceholders can be used to replace values in configuration files and are useful for to inject values from external\nsources into your code.\n\n---\n\n## Introduction\n\nWhen a developer designs an application for distribution, they generally need to be able to customise its configurations,\nso we generally end up with configuration files written in `yaml` or `json`.\n\nThis configuration imposes two major constraints:\n\n- The data structure is important and is required for the application to function properly\n- The values are static and cannot be changed without modifying the configuration file.\n\nThis second point is certainly the most important, as it is necessary to allow the application to function in a totally\ntransparent way depending on the environment in which it is evolving.\n\nWe can therefore conclude that it is necessary to be able to inject values into the configuration files.\n\n---\n\n## Usage\n\nDefine a `config.yaml` configuration file containing a `sayHello` key with the value `Hello {username} {emoji}`.\n\n:::code-group labels=[config.yaml]\n\n```yaml\nsayHello: Hello {username} {emoji}\n```\n\n:::\n\n### Static\n\n:::code-group labels=[main.dart]\n\n```dart\nvoid main() async {\n  final config = await File('config.yaml').readAsYaml();\n  // [!code ++:3]\n  final placeholder = Placeholder(values: {\n    'emoji': 'ðŸ‘‹',\n  });\n\n  final value = placeholder.apply(config['sayHello']); // [!code ++]\n  print(value); // Hello {username} ðŸ‘‹\n}\n```\n\n:::\n\nWe then instantiated a `Placeholder` object containing a set of values to inject into our configuration file.\nFinally, we applied our placeholder to our configuration value.\n\nWe can see that the `emoji` slot has been replaced by ðŸ‘‹ but not the `username` key. This is because the `username`\nvalue has not been declared in our placeholder.\n\n### Dynamic\n\nThe `Placeholder` component can also be used to declare dynamic values, i.e. values that can be modified at runtime.\n\nLet's take the example of the `MessageCreate` event in our Discord client.\n\n```dart\nvoid main() async {\n  final config = await File('config.yaml').readAsYaml();\n  final placeholder = Placeholder(values: {\n    'emoji': 'ðŸ‘‹',\n  });\n\n  client.events.server.messageCreate((ServerMessage message) async {\n    if (!message.authorIsBot) {\n      final author = await message.resolveMember();\n\n      final str = placeholder.apply(config['sayHello'], values: {\n        'username': message.author.username, // [!code ++]\n      });\n\n      final builder = MessageComponentBuilder()\n        ..text(str);\n\n      await message.reply(builder); // Hello John ðŸ‘‹\n    }\n  });\n}\n```\n\n## Case study\n\nIn this exercise, we will try out the example of a ticketing module.\n\n- Sending a drop-down menu to choose a ticket type\n- Creation of a chat room with specific permissions\n\nThe declaration enabling this variability is provided thanks to the notion of environment via data injection\nin the runtime.\n\n> [!note]\n> Find out how environments work in the [dedicated section](/guide/environment-variables).\n\n### Declaration\n\nFirst, we will declare the environment variables required for our ticketing module to function correctly.\n\n:::code-group labels=[config.yaml, .env]\n\n```yaml\ntickets:\n  requestRole:\n    name: Request role\n    description: Request a role on the server\n    roles:\n      - 1333087322459344936\n      - 1333087372446797947\n```\n\n```dotenv\nROLE_ADMIN=1333087322459344936\nROLE_MODERATOR=1333087372446797947\n```\n\n:::\n\nIn this example, we declare a ticket with the unique identifier `requestRole`, which will be used to request a role on\nthe server, and we also have a list of roles authorised to handle this type of ticket.\n\nWe can now make a modification to our configuration file.\n\n:::code-group labels=[config.yaml]\n\n```yaml\ntickets:\n  requestRole:\n    name: Request role\n    description: Request a role on the server\n    roles:\n      - { env.ROLE_ADMIN }\n      - { env.ROLE_MODERATOR }\n```\n\n:::\n\n### Data model\n\nLet's declare the data model that allows us to interact with our configuration file.\n\n:::code-group labels=[ticket.dart]\n\n```dart\nfinal class Ticket {\n  final String uid;\n  final String name;\n  final String description;\n  final List\u003Cint> roles;\n\n  Ticket({\n    required this.uid,\n    required this.name,\n    required this.description,\n    required this.roles,\n  });\n\n  factory Ticket.of(String uid, Map\u003CString, dynamic> payload) {\n    return Ticket(\n      uid: payload['uid'],\n      name: payload['name'],\n      description: payload['description'],\n      roles: List.from(payload['roles'])\n        .map(Snowflake.parse)\n        .toList(),\n    );\n  }\n}\n```\n\n:::\n\nWe can now load our configuration file and instantiate our data model.\n\n:::code-group labels=[main.dart]\n\n```dart\nvoid main() async {\n  final config = await File('config.yaml').readAsYaml();\n\n  final List\u003CTicket> tickets = config['tickets'].entries\n    .map((entry) => Ticket.of(entry.key, entry.value))\n    .toList();\n\n  print(tickets);\n}\n```\n\n:::\n\n---\n\n### Injection\n\nAt this stage, we have converted our configuration file into a data model that can be used by our application.\n\nWe now need to apply our environment variables to our entities. There are two ways of doing this:\n\n1. Conversion at instantiation of each `Ticket` model\n2. Conversion on reading the value\n\nIn our case, we'll opt for an injection on reading the value when choosing a ticket type from a select menu.\n\n> [!note]\n> We'll use an **interactive component**, more information in the [dedicated section](/fundamentals/interactive-components).\n\n:::code-group labels=[render, handling, inject]\n\n```dart\nfinal class MessageTicketComponent implements InteractiveSelectMenu {\n  @override\n  String get customId => 'tickets::trigger';\n\n  // [!code ++:2]\n  final List\u003CTicket> tickets;\n  MessageTicketComponent(this.tickets);\n\n  @override\n  SelectMenuBuilderContract build() {\n    final builder = SelectMenuBuilder.text(customId)\n      ..setPlaceholder('Please select a ticket');\n\n    // [!code ++:6]\n    for (final ticket in tickets) {\n      builder.addOption(\n        label: ticket.name,\n        value: ticket.uid,\n      );\n    }\n\n    return builder;\n  }\n}\n```\n\n```dart\nfinal class MessageTicketComponent implements InteractiveSelectMenu {\n  @override\n  String get customId => 'tickets::trigger';\n\n  final List\u003CTicket> tickets;\n  MessageTicketComponent(this.tickets);\n\n  @override\n  Future\u003Cvoid> handle(SelectContext ctx, values) async {\n    if (ctx case ServerSelectContext ctx) {\n      final ticket = tickets.firstWhere((ticket) => ticket.uid == ticketUid);\n      final server = await ctx.message.resolveServer();\n\n      await server.channels.create(\n        ChannelBuilder.text()\n          ..setName('Ticket of ${ticket.name}')\n          ..setPermissionOverwrite([\n            // [!code ++:5]\n            ChannelPermissionOverwrite(\n              id: server.id.value,\n              deny: [Permission.viewChannel],\n              type: ChannelPermissionOverwriteType.role,\n            ),\n\n            // [!code ++:7]\n            for (final role in ticket.roles) {\n              ChannelPermissionOverwrite(\n                id: role,\n                allow: [Permission.viewChannel],\n                type: ChannelPermissionOverwriteType.role,\n              );\n            }\n          ]);\n    }\n  }\n\n  @override\n  SelectMenuBuilderContract build() { ...}\n}\n```\n\n```dart\nfinal class MessageTicketComponent implements InteractiveSelectMenu {\n  @override\n  String get customId => 'tickets::trigger';\n\n  final placeholder = EnvPlaceholder(); // [!code ++]\n\n  final List\u003CTicket> tickets;\n  MessageTicketComponent(this.tickets);\n\n  @override\n  Future\u003Cvoid> handle(SelectContext ctx, values) async {\n    if (ctx case ServerSelectContext ctx) {\n      final ticket = tickets.firstWhere((ticket) => ticket.uid == ticketUid);\n      final server = await ctx.message.resolveServer();\n\n      await server.channels.create(\n        ChannelBuilder.text()\n          ..setName('Ticket of ${ticket.name}')\n          ..setPermissionOverwrite([\n            for (final role in ticket.roles) {\n              ChannelPermissionOverwrite(\n                id: role, // [!code --]\n                id: placeholder.apply(role), // [!code ++]\n                allow: [Permission.viewChannel],\n                type: ChannelPermissionOverwriteType.role,\n              );\n            }\n          ]);\n    }\n  }\n\n  @override\n  SelectMenuBuilderContract build() { ...}\n}\n```\n\n:::\n\nNow that our component has been created, we need to send our menu to a target channel.\n\nFor our example, we'll use the channel in which the command will be executed.\n\n:::code-group labels=[command.dart]\n\n```dart\nfinal class TicketCommand with Component implements CommandDeclaration {\n  Future\u003Cvoid> handle(ServerCommandContext ctx) async {\n    if (ctx.channel case ServerTextChannel channel) {\n      final menu = components.get('tickets::trigger'); // [!code ++]\n\n      final builder = MessageComponentBuilder()\n        ..text('please select a ticket')\n        ..selectMenu(menu);\n\n      await channel.send(builder);\n    }\n  }\n\n  @override\n  CommandDeclarationBuilder build() {\n    return CommandDeclarationBuilder()\n      ..setName('ticket')\n      ..setDescription('This is a ticket command')\n      ..setHandle(handle);\n  }\n}\n```\n\n:::\n\nFinally, we need to register our component with our client.\n\n:::code-group labels=[main.dart]\n\n```dart\nvoid main() async {\n  final config = await File('config.yaml').readAsYaml();\n\n  final List\u003CTicket> tickets = config['tickets'].entries\n    .map((entry) => Ticket.of(entry.key, entry.value))\n    .toList();\n\n  final client = ClientBuilder()\n    .build();\n\n  // [!code ++:2]\n  client.register(() => MessageTicketComponent(tickets));\n  client.register(TicketCommand.new);\n\n  await client.init();\n}\n```\n\n:::\n\n## Extension\n\nCreate your own placeholder by implementing the `PlaceholderContract` interface.\n\n:::code-group labels=[placeholder.dart, contract]\n\n```dart\nfinal class MyPlaceholder implements PlaceholderContract {\n  final Map\u003CString, dynamic> _values = {};\n\n  @override\n  String get identifier => 'my';\n\n  @override\n  Map\u003CString, dynamic> get values => _values;\n\n  @override\n  String apply(String value) {\n    return values.entries.fold(value, (acc, element) {\n      final finalValue = switch (element.value) {\n        String() => element.value,\n        int() => element.value.toString(),\n        _ => throw Exception('Invalid type')\n      };\n\n      return acc\n        .replaceAll('{${element.key}}', finalValue)\n        .replaceAll('{{ ${element.key} }}', finalValue);\n    });\n  }\n}\n```\n\n```dart\nabstract interface class PlaceholderContract {\n  Map\u003CString, dynamic> get values;\n  String? get identifier;\n  String apply(String value);\n}\n```\n\n:::","src/content/docs/api/placeholders.mdx","2483be557d077b59","providers",{"id":143,"data":145,"body":148,"filePath":149,"digest":150,"deferredRender":21},{"title":146,"description":15,"permalink":143,"order":16,"icon":147},"Providers","lucide:picture-in-picture","# Providers\n\nIn a more modular approach, we often want to declare our events, commands, etc. on a different entry point from the main file.\n\nTo this end, the provider principle allows you to compartmentalise your application code into a single entry point, which can then be imported into your `main.dart`.\n\n---\n\n## Introduction\n\nA modular architecture is often desired to declare our events, commands, etc. on a different entry point from the main file.\nA representative and recurring structure for a more business-oriented architecture might be as follows :\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”œâ”€â”€ lib\nâ”‚  â”œâ”€â”€ application\nâ”‚  â”‚  â””â”€â”€ tickets\nâ”‚  â”‚     â”œâ”€â”€ commands\nâ”‚  â”‚     â”œâ”€â”€ events\nâ”‚  â”‚     â””â”€â”€ ticket_provider.dart\nâ”‚  â”œâ”€â”€ domain\nâ”‚  â””â”€â”€ infrastructure\n```\n\n---\n\n## Usage\n\nProviders are very easy to use, allowing you to declare your events, commands and much more in the constructor \nof a simple class.\n\n### Create an provider\nFirst, we will execute a command from the CLI of the Mineral framework.\n\n```bash\nmineral make:provider \u003Cname>\n```\n\n### Declaring a provider\nA provider is a class that allows you to declare your events, commands, etc. in a modular way.\n\n:::code-group labels=[ticket_provider.dart]\n```dart\nfinal class TicketProvider extends Provider {\n  final Client _client;\n\n  TicketProvider(this._client) {\n    // [!code ++:2]\n    _client.register(TicketCommands.new);\n    _client.register(TicketEvent.new);\n  }\n}\n```\n:::\n\nIn this case, we want to record all our events and commands relating to our `ticket` module in a `ticket_provider.dart`\nprovider which will then be imported into your application's `main.dart`.\n\n:::code-group labels=[main.dart]\n```dart\nvoid main(_, port) async {\n  final client = ClientBuilder()\n      .setHmrDevPort(port)\n      .registerProvider(TicketProvider.new) // [!code ++]\n      .build();\n  \n  await client.init();\n}\n```\n:::\n\n---\n\n## Event lifecycle\n\nWhen your application loads your providers, they will automatically record your events and commands declared as constructors in the client.\n\nHowever, it is possible to declare actions at certain points in your application's lifecycle.\n\nThe interaction points are as follows:\n- `ready`: When your bot has started up\n- `dispose`: When your application is in the process of stopping.\n\n```dart\nfinal class TicketProvider extends Provider {\n  final Client _client;\n\n  TicketProvider(this._client) {\n    _client.register(TicketCommands.new);\n    _client.register(TicketEvent.new);\n  }\n  \n  // [!code ++:2]\n  @override\n  FutureOr\u003Cvoid> ready() {}\n  \n  // [!code ++:2]\n  @override\n  FutureOr\u003Cvoid> dispose() {}\n}\n```","src/content/docs/api/providers.mdx","fb80849002999276","guide",["Map",54,153,107,158,116,163,168,169,176,177,184,185],{"id":54,"data":154,"body":155,"filePath":156,"digest":157,"deferredRender":21},{"title":57,"description":15,"permalink":54,"order":93,"icon":58},"# Commands\n\nSlash commands were implemented with the aim of replacing messages considered as commands with a start-of-line\ncharacter, often defined as a message prefix like `!`.\n\n> [!important]\n> Please see the dedicated [section](/docs/api/commands) for more information.\n\n---\n\n## Introduction\n\nThe Discord API allows users to interact with bots in a more intuitive and structured way, using predefined syntax to make it easier to execute specific commands without having to remember prefixes or complex message formats.\n\nThey were created to replace message-based commands with prefixes, making the user experience smoother and reducing\nsyntax errors.\n\n> [!note]\n> When you change the structure of your commands, please restart your entire application process so that the changes take\n> effect even if the `hmr` is active.\n\n## Builder approach\n\nFrom the `Client`, we can chain commands listeners using the following pattern :\n\n:::code-group labels=[main.dart]\n\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.commands.declare((command) {\n    command\n      ..setName('foo')\n      ..setDescription('This is a command description')\n      ..setHandler((ctx) => ctx.interaction.reply('Hello, world!'));\n  });\n\n  await client.init();\n}\n```\n\n:::\n\n---\n\n## Object-oriented approach\n\nFor benchmarking purposes, we recommend using the `functional` approach, but when developing applications requiring\nmore than 2 events or commands, we recommend using the object-oriented approach.\n\n:::code-group labels=[command.dart, main.dart]\n\n```dart\nfinal class MyCommand implements CommandDeclaration {\n  void handle(CommandContext ctx) {\n    print('Hello, world!');\n  }\n\n  @override\n  CommandDeclarationBuilder build() {\n    return CommandDeclarationBuilder()\n      ..setName('foo')\n      ..setDescription('This is a command description')\n      ..setHandler(handle);\n  }\n}\n```\n\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.register(MyCommand.new);\n\n  await client.init();\n}\n```\n\n:::","src/content/docs/guide/commands.mdx","18f867ab02c7a978",{"id":107,"data":159,"body":160,"filePath":161,"digest":162,"deferredRender":21},{"title":110,"description":15,"permalink":111,"order":102,"icon":112},"# Events\n\nThe Discord API uses a real-time event system transmitted via a WebSocket connection to allow client applications to receive instant updates from the server.\n\n> [!important]\n> Please see the dedicated [section](/docs/api/events) for more information.\n\n---\n\n## Introduction\n\nWhen a bot or application connects to the Discord gateway, it receives a continuous stream of events, such as new messages, user status changes, channel changes, and much more.\n\nAn event listener is a function that listens to a specific event and triggers an action when the event is dispatched.\n\nBasically, Mineral offers an event system that can be used in two different ways.\n\n---\n\n## Functional approach\n\nLet's take a simple example of a bot that listens to the `MessageCreate` event and prints the message content to the console.\n\nFrom the `Client`, we can chain event listeners using the following pattern :\n\n:::code-group labels=[boilerplate, main.dart]\n\n```dart\nclient.events.\u003Ccontext>.\u003Cevent>(\u003Clistener>)\n```\n\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.events.server.messageCreate((message) {\n    print(message.content);\n  });\n\n  await client.init();\n}\n```\n\n:::\n\n---\n\n## Object-oriented approach\n\nFor benchmarking purposes, we recommend using the `functional` approach, but when developing applications requiring\nmore than 2 events or commands, we recommend using the object-oriented approach.\n\n:::code-group labels=[boilerplate, message_create.dart, main.dart]\n\n```dart\nfinal class \u003CClassName> extends \u003CEvent> {\n  @override\n  FutureOr\u003Cvoid> handle(\u003Cparams>) {\n    // Your business code here\n  }\n}\n```\n\n```dart\nfinal class MessageCreate extends MessageCreateEvent {\n  @override\n  void handle(ServerMessage message) {\n    print(message.content);\n  }\n}\n```\n\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.register(MessageCreate.new);\n\n  await client.init();\n}\n```\n\n:::","src/content/docs/guide/event.mdx","75be5bcf91fe6a1e",{"id":116,"data":164,"body":165,"filePath":166,"digest":167,"deferredRender":21},{"title":119,"description":15,"permalink":116,"order":66,"icon":120},"# Environment variables\n\nEnvironment variables serve the purpose of storing secrets like the database password, the app secret, or an API key outside of your application codebase.\n\nIn addition, environment variables can be used to obtain different configurations depending on the environment, such as the use of a secret to use an API or database identifiers.\n\n> [!note]\n> Please read the full documentation of the environment in the dedicated [section](/docs/api/environment-variables).\n\n---\n\nWe're providing an `Environment` class to access the various environment variables in your application.\n\n:::code-group labels=[.env, schema.dart]\n\n```dotenv\nDART_ENV=development\nTOKEN=your_token\nDISCORD_REST_API_VERSION=10\nDISCORD_WS_VERSION=10\nINTENT=3276799\nLOG_LEVEL=TRACE\n```\n\n```dart\nfinal class AppEnv implements DefineEnvironment {\n  static final String dartEnv = 'DART_ENV';\n  static final String token = 'TOKEN';\n  static final String discordRestHttpVersion = 'DISCORD_REST_API_VERSION';\n  static final String discordWssVersion = 'DISCORD_WS_VERSION';\n  static final String intent = 'INTENT';\n  static final String logLevel = 'LOG_LEVEL';\n\n  @override\n  final Map\u003CString, EnvSchema> schema = {\n    dartEnv: env.enumerable(DartEnv.values),\n    token: env.string(),\n    discordRestHttpVersion: env.number(),\n    discordWssVersion: env.number(),\n    intent: env.number(),\n    logLevel: env.enumerable(LogLevel.values),\n  };\n}\n\nenum DartEnv implements Enumerable\u003CString> {\n  development('development'),\n  production('production');\n\n  @override\n  final String value;\n\n  const DartEnv(this.value);\n}\n```\n\n:::","src/content/docs/guide/environment-variables.mdx","b711c5332bdcae53","installation",{"id":168,"data":170,"body":173,"filePath":174,"digest":175,"deferredRender":21},{"title":171,"description":15,"permalink":168,"order":26,"icon":172},"Installation","lucide:play","# Installation\n\nBefore embarking on this crazy discord adventure, you will need to follow the steps outlined below to set up a clean and healthy project.\n\n---\n\n## Prerequisites\n\nPlease make sure you have the following tools installed on your machine before you start.\n\n### Dart lang\n\nThe Mineral framework has been developed entirely in the Dart programming language, so you will need to install it in your development environment first. In order to best install it, please refer to the [official documentation](https://dart.dev/get-dart).\n\n> [!note]\n> The version of the Dart language sdk must be at least `^3.5.2`.\n\n---\n\n## Setup new project\n\n### From the CLI\n\nYou can use the Mineral CLI to create a new project.\n\nFollow the steps below to install the CLI.\n\n:::code-group auto\n\n```bash\ndart pub global activate mineral_cli [version]\n\ncd path/to/your/projects\nmineral create my_project\n```\n\n:::\n\n> [!note]\n> More details about the CLI can be found in the [`command line`](/docs/api/cli) section.\n\n---\n\n### From scratch\n\nUse the following command to start a new blank Dart project.\n\n```bash\ndart create my_project\n```\n\nAfter creating the project, you will need to add the Mineral framework to your `pubspec.yaml` file.\n\n:::code-group labels=[pubspec.yaml]\n\n```yaml\ndependencies:\n  mineral: ^4.0.0-dev.11\n  mineral_cache: ^1.0.0-dev.4\n```\n\n:::\n\n> [!note]\n> Please verify the lasted version of the [`core`](https://pub.dev/packages/mineral) and [`cache`](https://pub.dev/packages/mineral_cache) packages directly on registry.\n\nThen run the following command to install the dependencies.\n\n:::code-group auto\n\n```bash\ndart pub get\n```\n\n:::\n\nMake sure you have the following minimal structure in your project.\nThe `.env` file is not created by default when you start a new Dart project, don't forget to create it.\n\n:::code-group labels=[boilerplate, .env]\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\n```dotenv\nDART_ENV=development\nTOKEN=your_discord_token\nDISCORD_REST_API_VERSION=12\nDISCORD_WS_VERSION=12\nINTENT=3276799\nLOG_LEVEL=info\n```\n\n:::\n\n### Application\n\nThe `main.dart` file is the entry point of your application. This is where you will start your bot.\n\n:::code-group labels=[main.dart]\n\n```dart\nvoid main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  await client.init();\n}\n```\n\n:::\n\nTo check that your application is working properly, we recommend that you use the `ready` event.\n\n:::code-group labels=[main.dart]\n\n```dart\nvoid main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  // [!code ++:3]\n  client.events.ready((Bot bot) {\n    client.logger.info('${bot.username} is ready ! ðŸš€');\n  });\n\n  await client.init();\n}\n```\n\n:::\n\n## Running the application\n\nFinally, you can run your application with the following command.\n\n:::code-group auto\n\n```bash\ndart run src/main.dart\n```\n\n:::","src/content/docs/guide/installation.mdx","77d31b44327b302f","structure",{"id":176,"data":178,"body":181,"filePath":182,"digest":183,"deferredRender":21},{"title":179,"description":15,"permalink":176,"order":16,"icon":180},"Structure","lucide:folder-tree","# Structure\n\nThe folder structure of a project is very important.\nIt helps you to organize your project in a better way. It also helps you to understand the project structure easily.\n\nIn this guide, we will discuss the folder structure of a project.\n\n---\n\n## Minimal structure\n\nThe minimal structure proposed by the project consists of a simple source folder containing your business code.\nThe `bin` folder is used to use the `hmr` component in your application during the development phase; you can change the name of the `source` folder, but we do not recommend deleting it.\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ lib\nâ”‚  â”œâ”€â”€ events\nâ”‚  â””â”€â”€ commands\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nThis architecture is classic in the world of Discord bots. It's simple yet meets the need for rapid implementation.\n\nOne of the limitations arises when your application grows more or less drastically: you'll end up with a multitude of files at the same level, which can lead to poor understanding of your application.\n\n---\n\n## N-tier structure\n\nWhen you're developing increasingly complex applications, you generally lose readability and maintainability\nand maintainability if you don't focus on a stable, future-proof software architecture.\n\n> [!note]\n> We recommend the following structure.\n\nOne approach we recommend is the module-based architecture.\nThis involves dividing your application into several business modules that are independent of each other.\n\n```\nâ”œâ”€â”€ assets\nâ”‚  â”œâ”€â”€ image1.png\nâ”‚  â””â”€â”€ image2.png\nâ”‚\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ lib\nâ”‚  â”œâ”€â”€ commons\nâ”‚  â”‚  â”œâ”€â”€ helper.dart\nâ”‚  â”‚  â””â”€â”€ api.dart\nâ”‚  â”‚\nâ”‚  â”œâ”€â”€ first_module\nâ”‚  â”‚  â”œâ”€â”€ events\nâ”‚  â”‚  â”œâ”€â”€ commands\nâ”‚  â”‚  â””â”€â”€ provider.dart\nâ”‚  â”‚\nâ”‚  â””â”€â”€ second_module\nâ”‚     â”œâ”€â”€ events\nâ”‚     â”œâ”€â”€ commands\nâ”‚     â””â”€â”€ provider.dart\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nThis architecture has several notable advantages: it allows you to:\n\n- divide your application code into modules, each representing a business fragment\n- simplifies the integration of your code across multiple projects thanks to [`providers`](/docs/api/providers)\n\nIn this architecture, we use [`providers`](/docs/api/providers) allowing us to \"move\" the entry point of our module in order to facilitate the segmentation of our code.\n\nTo simplify the management of your modules, we recommend that you create a `provider.dart` file within each which will\nserve as the entry point for each module.\n\n:::code-group labels=[main.dart, module/provider.dart]\n\n```dart\nfinal client = Client()\n  .registerProvider(Provider.new) // [!code ++]\n  .build();\n```\n\n```dart\nfinal class Provider extends Provider {\n  final MineralClientContract _client;\n\n  Provider(this._client) {\n    _client.register(MyEvent.new); // [!code ++]\n    _client.registerCommand(MyCommand.new); // [!code ++]\n  }\n}\n```\n\n:::\n\n---\n\n## Layered architecture\n\nWhen we talk about modular architecture, we quickly come to hexagonal architecture.\nThis architecture allows you to decouple the different parts of your application according to their core business and\nresponsibility within it.\n\n> [!note]\n> We recommend the following structure.\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ lib\nâ”‚  â”œâ”€â”€ ui\nâ”‚  â”‚  â”œâ”€â”€ events\nâ”‚  â”‚  â”‚  â”œâ”€â”€ ready_event.dart\nâ”‚  â”‚  â”‚  â””â”€â”€ message_create_event.dart\nâ”‚  â”‚  â”‚\nâ”‚  â”‚  â””â”€â”€ commands\nâ”‚  â”‚     â””â”€â”€ foo_command.dart\nâ”‚  â”‚\nâ”‚  â”œâ”€â”€ services\nâ”‚  â”‚  â””â”€â”€ foo_service.dart\nâ”‚  â”‚\nâ”‚  â”œâ”€â”€ data\nâ”‚  â”‚  â”œâ”€â”€ models\nâ”‚  â”‚  â””â”€â”€ repositories\nâ”‚  â”‚\nâ”‚  â””â”€â”€ provider.dart\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nThe above structure is an example that we recommend to help you adopt a modular, scalable and maintainable architecture by decoupling the different parts of your application as much as possible.\nHowever, it will not always suit your business needs and will need to be adapted accordingly.\n\n| Directory  | Description                                                                                                                                                                               |\n| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `ui`       | Contains the various parts of your application which are related to your business, including `events` and `commands`.                                                                     |\n| `services` | Contains the services which allow you to manipulate the data in your application; they will generally be used from the `ui`.                                                              |\n| `data`     | Contains the DTOs and repositories that allow you to manipulate the data in your application. An example of use is the use of a remote REST service to which you need to make HTTP calls. |\n| `provider` | The entry point of your module who's call under the `main` file.                                                                                                                          |\n\n---\n\n## Hexagonal architecture\n\nWhen we talk about modular architecture, we quickly come to hexagonal architecture.\nThis architecture allows you to decouple the different parts of your application according to their core business and\nresponsibility within it.\n\n> [!note]\n> We recommend the following structure.\n\n```\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”‚\nâ”œâ”€â”€ lib\nâ”‚  â””â”€â”€ application\nâ”‚  â”‚  â””â”€â”€ tickets\nâ”‚  â”‚     â”œâ”€â”€ commands\nâ”‚  â”‚     â”œâ”€â”€ events\nâ”‚  â”‚     â””â”€â”€ ticket_provider.dart\nâ”‚  â”‚\nâ”‚  â”œâ”€â”€ domain\nâ”‚  â”‚  â””â”€â”€ tickets\nâ”‚  â”‚     â”œâ”€â”€ entities\nâ”‚  â”‚     â”œâ”€â”€ repositories\nâ”‚  â”‚     â”œâ”€â”€ dtos\nâ”‚  â”‚     â””â”€â”€ contracts\nâ”‚  â”‚\nâ”‚  â””â”€â”€ infrastructure\nâ”‚     â””â”€â”€ tickets\nâ”‚        â”œâ”€â”€ repositories\nâ”‚        â””â”€â”€ dtos\nâ”‚\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nThis architecture has several notable advantages: it allows you to:\n\n- divide your application code into modules, each representing a business fragment\n- simplifies the integration of your code across multiple projects thanks to [`providers`](/docs/api/providers)\n- isolate the business logic of your application from the infrastructure layer\n\nThe `application` directory contains all of our business context divided into modules, allowing better readability and maintainability of our code.\n\n| Directory        | Description                                                                                                                                                                                                           |\n| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `bin`            | Contains the entry point of your application.                                                                                                                                                                         |\n| `application`    | Contains the various parts of your application which are related to your business, including `events`, `commands`, `states` or any mineral component, it can be split into modules.                                   |\n| `domain`         | Contains the entities, DTOs, repositories, contracts that allow you to manipulate the data in your application. He contains the business logic of your application and must not depend on anything other than itself. |\n| `infrastructure` | Contains implementations that must interact with external services such as APIs, BDDs and queues. Each implementation must implement a contract defined in the domain.                                                |\n\n> [!note]\n> You can find a sample implementation of this architecture [here](https://github.com/LeadcodeDev/mineral_beta_bot_demo).","src/content/docs/guide/structure.mdx","628b3b307ab5e3ce","deployment",{"id":184,"data":186,"body":189,"filePath":190,"digest":191,"deferredRender":21},{"title":187,"description":15,"permalink":184,"order":93,"icon":188},"Deployment","lucide:rocket","# Deployment\n\nDeployment is an extremely important part of the process, but one that most developers dread because it falls outside the developer's core business and into that of devops.\n\n> [!important]\n> We recommend deploying via a docker system, see the [dedicated section](/docs/guide/deployment#docker).\n\n---\n\n## Build your application\n\nThe principal aim of Mineral is to simplify the developer experience. \nThat's why we've created a simple command to build your application and create an executable. \n\nThis executable is a single file that you can deploy anywhere, without having to worry about dependencies or other configuration. \n\nBesides, this allows you to share only the executable with your customers and not all the source code.\n\n> [!warning]\n> Dart creates an executable for your operating system. If you build on Windows, you will receive a Windows executable which doesn't work on Linux.\n\nWe're using the `dart compile exe` command to build your application in `dist` directory.\n\n:::code-group auto\n```bash\ndart compile exe bin/main.dart -o ./dist/main.exe\n```\n:::\n\n---\n\n## Deploy with pm2\n\nPM2 is a production process manager for any applications that helps you keep applications alive forever and reload them without downtime. It plays a crucial role in deployment by managing your application's lifecycle, handling crashes, and providing monitoring capabilities.\n\n:::code-group labels=[ecosystem.config.js]\n```js\nmodule.exports = {\n  apps: [\n    {\n      name: \"discord-bot\",\n      script: \"./dist/main.exe\",\n      interpreter: \"none\",\n      watch: false,\n      env: {\n        DART_ENV: \"production\",\n        TOKEN: \"your_token\",\n        DISCORD_REST_API_VERSION: 10,\n        DISCORD_WS_VERSION: 10,\n        INTENT: \"3276799\",\n        LOG_LEVEL: \"TRACE\"\n      },\n      error_file: \"./logs/err.log\",\n      out_file: \"./logs/out.log\",\n      log_date_format: \"YYYY-MM-DD HH:mm:ss\",\n      restart_delay: 5000\n    }\n  ]\n};\n```\n:::\n\n### Start PM2 and manage processes\n\nOnce your ecosystem configuration is set up, you can start and manage your application with PM2 :\n\n:::code-group labels=[start, list, logs, restart, stop]\n```bash\n# Start the application\npm2 start ecosystem.config.js\n```\n```bash\n# List all running processes\npm2 list\n```\n```bash\n# View logs\npm2 logs discord-bot\n```\n```bash\n# Restart the application\npm2 restart discord-bot\n```\n```bash\n# Stop the application\npm2 stop discord-bot\n```\n:::\n\n---\n\n## Docker\n\nDocker is a powerful cross-platform containerisation tool that is widely used in the professional world.\n\nBefore starting a deployment with Docker, please refer to the [official documentation](https://www.docker.com) to ensure that your installation is correct.\n\n### Build your image\n\nNow that your installation is done, we will create a Dockerfile at the root of our project with the following information. In our instructions we use the official Docker image of the Dart language.\n\n:::code-group auto\n```dockerfile\nFROM dart:stable AS build\n\nWORKDIR /app\nCOPY . /app\nWORKDIR /app\n\nRUN dart pub get\nRUN dart compile exe src/main.dart -o mineral\n\nFROM scratch\nCOPY --from=build /runtime /\nCOPY --from=build /app/mineral /app/\nCOPY --from=build /app/pubspec.yaml /\n\nCMD [\"/app/mineral\"]\n```\n:::\n\n---\n\n### Docker CLI\n\nNow that the Docker image is configured, all we have to do is build it with the following command and then start it.\n\n:::code-group labels=[build, start]\n```bash\ndocker build -t [name]:latest .\n```\n```bash\ndocker run -d --name [display_name] [name]\n```\n:::\n\n---\n\n### Docker Compose\n\nDocker Compose is a tool that allows you to manage multiple containers at the same time. It can be very useful if you want to deploy your application with a database for example.\n\nTo use it, you just have to create a docker-compose.yml file at the root of your project with the following information.\n\n:::code-group labels=[docker-compose]\n```yaml\nversion: '3.8'\n\nservices:\n  bot:\n    container_name: bot\n    image: mineral\n    restart: always\n    environment:\n      - DART_ENV=production\n      - TOKEN=your_token\n      - DISCORD_REST_API_VERSION=10\n      - DISCORD_WS_VERSION=10\n      - INTENT=3276799\n      - LOG_LEVEL=TRACE\n```\n:::\n\nIf you have chosen `Redis` as your caching solution, please add the service to the `docker-compose.yaml`.\n\n:::code-group labels=[docker-compose]\n```yaml\nversion: '3.8'\n\nservices:\n  bot:\n    container_name: bot\n    image: mineral\n    restart: always\n    # [!code ++:2]\n    depends_on:\n      - cache\n    environment:\n      - DART_ENV=production\n      - TOKEN=your_token\n      - HTTP_VERSION=10\n      - WSS_VERSION=10\n      - INTENT=3276799\n      - LOG_LEVEL=TRACE\n  # [!code ++:8]\n  cache:\n    container_name: cache\n    image: redis\n    restart: always\n    ports:\n      - '6380:6379'\n    environment:\n      - REDIS_PASSWORD=redis\n```\n:::\n\n---\n\n## Kubernetes\n\nKubernetes is a powerful container orchestration platform that provides advanced deployment, scaling, and management capabilities for containerized applications. It's particularly useful for production environments where you need high availability, automatic scaling, and robust service discovery.\n\n### Prerequisites\n\nBefore deploying to Kubernetes, ensure you have:\n- A Kubernetes cluster (local with Minikube, cloud provider, or self-hosted)\n- `kubectl` CLI tool installed and configured\n- Your Docker image pushed to a container registry\n- Helm installed (for Helmfile deployment)\n\n### Basic Kubernetes Deployment\n\nCreate a basic Kubernetes deployment manifest for your Mineral application\n\n\nWe will consider the following structure for our application :\n\n```\nâ”œâ”€â”€ kubernetes\nâ”‚  â””â”€â”€ chart\nâ”‚     â”œâ”€â”€ templates\nâ”‚     â”‚  â””â”€â”€ deployment.yaml\nâ”‚     â”œâ”€â”€ Chart.yaml\nâ”‚     â””â”€â”€ values.yaml\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”œâ”€â”€ lib\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\n> [!warning]\n> You cannot use replicas because the bot is a client who subscribe to the Discord websocketgateway.\n> If you run `N` instances of the bot, you will have `N` identical events.\n\n:::code-group labels=[chart.yaml, deployment.yaml, values.yaml]\n```yaml\napiVersion: v2\nname: mineral-bot\ndescription: A Helm chart for Mineral Discord Bot\ntype: application\nversion: 0.1.0\nappVersion: \"1.0.0\"\n```\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mineral-bot\n  labels:\n    app: mineral-bot\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: mineral-bot\n  template:\n    metadata:\n      labels:\n        app: mineral-bot\n    spec:\n      containers:\n      - name: mineral-bot\n        image: your-registry/mineral:latest\n        env:\n          - name: DART_ENV\n            value: {{ .Values.dartEnv | quote  }}\n          - name: DISCORD_REST_API_VERSION\n            value: {{ .Values.discordRestApiVersion | quote  }}\n          - name: DISCORD_WS_VERSION\n            value: {{ .Values.discordWsVersion | quote  }}\n          - name: INTENT\n            value: {{ .Values.intent | quote  }}\n          - name: LOG_LEVEL\n            value: {{ .Values.logLevel | quote  }}\n          - name: TOKEN\n            valueFrom:\n              secretKeyRef:\n                name: {{ .Values.kubeSecret }}\n                key: token\n```\n```yaml\ndartEnv: production\ndiscordRestApiVersion: 10\ndiscordWsVersion: 10\nintent: '3276799'\nlogLevel: trace\n\nkubeSecret: mineral-credentials\n```\n:::\n\n---\n\n### Deploy with Helmfile\n\nHelmfile is a declarative way to deploy Helm charts, making it easier to manage complex Kubernetes deployments across multiple environments.\n\nWe will consider the following structure for our application :\n\n```\nâ”œâ”€â”€ kubernetes\nâ”‚  â”œâ”€â”€ chart\nâ”‚  â”‚  â”œâ”€â”€ templates\nâ”‚  â”‚  â”‚  â””â”€â”€ deployment.yaml\nâ”‚  â”‚  â”œâ”€â”€ Chart.yaml\nâ”‚  â”‚  â””â”€â”€ values.yaml\nâ”‚  â”‚\n// [!code ++:9]\nâ”‚  â””â”€â”€ helmfiles\nâ”‚     â”œâ”€â”€ helmfile.yaml\nâ”‚     â”‚\nâ”‚     â””â”€â”€ templates\nâ”‚        â”œâ”€â”€ development\nâ”‚        â”‚  â””â”€â”€ values.yaml\nâ”‚        â”‚\nâ”‚        â””â”€â”€ production\nâ”‚           â””â”€â”€ values.yaml\nâ”œâ”€â”€ bin\nâ”‚  â””â”€â”€ main.dart\nâ”œâ”€â”€ lib\nâ”œâ”€â”€ pubspec.yaml\nâ””â”€â”€ .env\n```\n\nCreate a `helmfile.yaml` to manage your deployment:\n\n:::code-group labels=[helmfile.yaml]\n```yaml\nenvironments:\n  development:\n  production:\n---\nreleases:\n  - name: mineral-bot\n    namespace: mineral\n    chart: ../chart\n    version: 0.1.0\n    values:\n      - ./{{ .Environment.Name }}/values.yaml\n```\n:::\n\n#### Environment-specific Values\n\nCreate environment-specific value files:\n\n:::code-group labels=[[environment]/values.yaml]\n```yaml\nimage:\n  tag: \"xxxxx\"\n```\n:::\n\n#### Deploy with Helmfile\n\nDeploy your application using Helmfile:\n\n:::code-group labels=[deploy]\n```bash\n# Deploy to the target environment\nhelmfile sync -f ./kubernetes/helmfiles/helmfile.yaml -e [environment]\n\n# List releases\nhelmfile -f ./kubernetes/helmfiles/helmfile.yaml list\n\n# Delete deployment\nhelmfile -f ./kubernetes/helmfiles/helmfile.yaml delete\n```\n:::\n\nThis Kubernetes and Helmfile setup provides a production-ready deployment with :\n- Multi-environment support\n- Health checks and monitoring\n- Redis integration\n- Secret management","src/content/docs/guide/deployment.mdx","ace88b45dc0f68ee","concepts",["Map",194,195,203,204,213,214],"data-caching",{"id":194,"data":196,"body":200,"filePath":201,"digest":202,"deferredRender":21},{"title":197,"description":198,"permalink":194,"order":26,"icon":199},"Data caching","Data caching is a mechanism that caches the data for the application.","lucide:database","# Data Caching\n\nWhen developing a Discord application, it is customary to save objects in memory. This has the advantage of making them instantly accessible, but also of preserving their integrity.\n\n---\n\n## Problem\nOn the scale of a small application, this does not have any harmful effects, but as your application evolves and has to accommodate more and more members, the memory is used more and more until it reaches a threshold that we call \"no return\", which in some cases can more or less impact the entire infrastructure on which your application is hosted.\n\n## Concrete example\n\nLet's imagine the hypothetical case of an application that has to support more than 5,000 Discord servers, each with more than 300,000 members.\n\n> [!note]\n> The values taken as examples, such as the number of Discord servers and the number of members on each, are hypothetical and fictitious.\n\nThis mass of data represents a considerable load on the memory of the machine hosting your application.\n\nTraditionally it is chosen to remove the existing Discord interaction library in its preferred language in order to abstract itself from its data management method, so the application reverts to a state of API call to the HTTP API and traditional listening on the Discord websocket in order to no longer depend on your application's memory.\n\n## Caching system\nThanks to Mineral's caching system, the management of this memory is deported to a caching provider that allows you to move this memory when it is needed, so you can move it to another machine.\n\nThanks to the Dart language, we can compile our applications in order to drastically reduce our power consumption. To this end, and in order to reduce this consumption as much as possible, which in some cases remains high, we are providing a caching service that can be used to deport the location of objects currently in memory to a remote service.\n\n> [!warning]\n> Please note that depending on your chosen caching solution, certain costs may apply.\n> This is particularly visible on cloud solutions that calculate your rates based on consumption.\n\nThe Mineral framework offers official support for several caching providers.\n\n---\n\n### Memory Provider\nThis is the simplest caching solution, as it simply stores the data in memory.\n\nTo use it, you need to add the `mineral_cache` package to your `pubspec.yaml` file and then declare its use in your Mineral client builder.\n\n:::code-group labels=[main.dart, pubspec.yaml]\n```dart\nfinal client = ClientBuilder()\n  .setCache(MemoryProvider.new) // [!code ++]\n  .build();\n```\n\n```yaml\ndependencies:\n  mineral_cache: ^0.0.1 # [!code ++]\n```\n:::\n\n> [!note]\n> No environment variable is required to use this provider.\n\n---\n\n### Redis Provider\nBased on a powerful caching solution, the Redis provider allows you to deport your growing memory to an external solution.\n\nTo use it, you need to add the `mineral_cache` package to your `pubspec.yaml` file and then declare its use in your Mineral client builder.\n\n:::code-group labels=[main.dart, pubspec.yaml]\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .setCache((_) => RedisProvider(\n      host: 'localhost',\n      port: 6379,\n      password: 'password',\n    ))\n    .build();\n}\n```\n```yaml\ndependencies:\n  mineral_cache: ^0.0.1 # [!code ++]\n```\n:::\n\nTo simplify the injection of environment variables, the provider provides an `factory` to used environment variables as default values.\n\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    // [!code --:5]\n    .setCache((_) => RedisProvider(\n      host: 'localhost',\n      port: 6379,\n      password: 'password',\n    ))\n    .setCache(RedisProvider.fromEnvironment) // [!code ++]\n    .build();\n}\n```\n\n> [!note]\n> It is important to note that using the `factory` automatically validates the variables required in your environment.\n\nThe minimum environment variables are :\n\n:::code-group labels=[.env, schema.dart]\n```dotenv\nREDIS_HOST=127.0.0.1\nREDIS_PORT=6380\nREDIS_PASSWORD=redis\n```\n```dart\nfinal class RedisEnv implements DefineEnvironment {\n  static final String redisHost = 'REDIS_HOST';\n  static final String redisPort = 'REDIS_PORT';\n  static final String redisPassword = 'REDIS_PASSWORD';\n\n  @override\n  final Map\u003CString, EnvSchema> schema = {\n    redisHost: env.string(),\n    redisPort: env.number(),\n    redisPassword: env.string(),\n  };\n}\n```\n:::\n\n## Extending the Cache Provider\nIf you want to use a caching solution that is not officially supported, you can extend Mineral's caching system by creating your own provider.\n\nTo do this, you need to create a class that extends the `CacheProvider` class and implement the methods that are required.\n\n:::code-group labels=[my_provider.dart, contract.dart]\n```dart\nfinal class MyProvider implements CacheProviderContract {\n  @override\n  String get name => 'my_provider';\n\n  @override\n  late final LoggerContract logger;\n  \n  // Implement all required methods and properties\n  // provided by the CacheProviderContract.\n}\n```\n\n```dart\nabstract interface class CacheProviderContract {\n  String get name;\n\n  abstract LoggerContract logger;\n\n  FutureOr\u003Cvoid> init();\n\n  Future\u003Cint> length();\n  Future\u003CList\u003CT>> getAll\u003CT extends dynamic>();\n  Future\u003CString?> get(String? key);\n  Future\u003CString> getOrFail(String key, { Exception Function()? onFail });\n  Future\u003Cbool> has(String key);\n  Future\u003Cvoid> put\u003CT>(String key, T object);\n  Future\u003Cvoid> remove(String key);\n  Future\u003Cvoid> removeMany(List\u003CString> key);\n  Future\u003Cvoid> clear();\n\n  Future\u003Cvoid> dispose();\n  Future\u003Cbool> getHealth();\n}\n```\n:::\n\nThen you can use your provider like this.\n```dart\nvoid main(_, port) {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .setCache((_) => MyProvider()) // [!code highlight]\n    .build();\n}\n```\n\nIf you want to use environment variables to configure your provider, you can create an `factory` named `fromEnvironment` to simplify injecting them.\n\n:::code-group labels=[main.dart, my_provider.dart, schema.dart]\n```dart\nvoid main(_, port) {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .setCache((_) => MyProvider()) // [!code --]\n    .setCache(MyProvider.fromEnvironment) // [!code ++]\n    .build();\n}\n```\n```dart\nfinal class MyProvider implements CacheProviderContract {\n  // Your complete implementationâ€¦\n  \n  factory MyProvider.fromEnvironment(env) {\n    // Validate before returning provider\n    env.defineOf(MyProviderEnv.values);\n    \n    return MyProvider();\n  }\n}\n```\n\n```dart\nfinal class MyProviderEnv implements DefineEnvironment {\n  static final String myHost = 'MY_HOST';\n  static final String myPort = 'MY_PORT';\n  static final String myPassword = 'MY_PASSWORD';\n\n  @override\n  final Map\u003CString, EnvSchema> schema = {\n    myHost: env.string(),\n    myPort: env.number(),\n    myPassword: env.string(),\n  };\n}\n```\n:::","src/content/docs/concepts/data-caching.mdx","4451b90e73578b72","datastore",{"id":203,"data":205,"body":210,"filePath":211,"digest":212,"deferredRender":21},{"title":206,"description":207,"permalink":203,"order":208,"icon":209},"Datastore","Data store is a concept that allows you to store the data for the application.",12,"lucide:satellite-dish","# Datastore\n\nIt plays an abstraction role in data retrieval, enabling centralised access to different sources such as caching solutions or external APIs such as Discord.\n\n---\n\n## Introduction\n\nLe datastore est une brique logicielle indispensable pour interagir avec le monde hors de notre application.\nDans notre cas nous l'utilisons afin d'effectuer des requÃªtes HTTP vers l'API HTTP de Discord, de plus il nous permet de travailler et d'abstraire 3 axes primordiaux :\n\n- Abstraction de la source de donnÃ©es (caching, restâ€¦)\n- RequÃªtes auprÃ¨s de l'API HTTP de Discord\n- SÃ©rialization des donnÃ©es bruts vers des classes\n\n---\n\n## Fonctionnement\n\nLe datastore est utilisÃ© Ã  chaque fois que vous tentez d'accÃ©der Ã  une donnÃ©e non distribuÃ©e directement par un Ã©vÃ¨nement ou que vous essayez d'effectuer une action vers l'API HTTP de Discord.\nLe schÃ©ma ci-dessous illustre le processus d'accÃ¨s aux donnÃ©es via le datastore.\n\n### Caching\n\nLorsqu'un utilisateur fait une requÃªte de donnÃ©es au datastore, celui-ci commence par vÃ©rifier si les donnÃ©es sont disponibles dans le cache. Si les donnÃ©es sont prÃ©sentes, elles sont rÃ©cupÃ©rÃ©es directement depuis le cache et renvoyÃ©es au datastore.\n\n### Discord API\n\nDans le cas contraire, le datastore effectue une requÃªte vers l'API HTTP Discord pour obtenir les donnÃ©es nÃ©cessaires. Une fois les donnÃ©es rÃ©cupÃ©rÃ©es, le datastore fait appel Ã  la brique `Marshaller` qui a pour rÃ´le de transformer, normaliser et sÃ©rialiser les donnÃ©es brutes en objets ou classes utilisables par l'application.\n\n> [!note]\n> Le `Marshaller` permet d'effectuer une scission propre de notre dÃ©pendance avec le monde extÃ©rieur.\n\nLes donnÃ©es transformÃ©es sont renvoyÃ©es Ã  l'utilisateur.\n\n```mermaid\nsequenceDiagram\n    autonumber\n\n    participant U as User\n    participant D as Datastore\n    participant C as Cache\u003Cbr>(optional)\n    participant DAPI as DiscordAPI\n\n    U->>D: Request data\n\n    alt Caching introspection\n      D->>C: Get data\n      C-->>D: Data\n    else HTTP Request\n      D->>DAPI: Fetch data\n      DAPI-->>D: Data\n    end\n\n    create participant M as marshaller\n\n    D->>M: Transform data\n    M-->>D: Normalize & Serialize\n    D-->>U: Data\n```\n\n## Usage\n\nLorsque vous utilisez une mÃ©thode devant effectuer une rÃ©cupÃ©ration de donnÃ©es,\n\n### Event flow\n\nVous pouvez utiliser le service `rest` directement depuis le client Mineral ou en rÃ©cupÃ©rant le service `Datastore` depuis l'`IoC`.\n\n:::code-group labels=[message_create.dart]\n\n```dart\nFuture\u003Cvoid> main() async {\n  final client = ClientBuilder()\n    .setCache(MemoryProvider.new)\n    .build();\n\n  client.events.server.createMessage((message) async {\n    final builder = MessageComponentBuilder()\n      ..text('Hello World ! ðŸš€');\n\n    // [!code highlight]\n    await message.reply(builder);\n  });\n\n  await client.init();\n}\n```\n\n:::\n\n### Explicit rest flow\n\nIl peut arriver que vous soyez amenÃ© Ã  rÃ©cupÃ©rer des donnÃ©es en dehors d'une rÃ©action Ã  un Ã©vÃ¨nement.\nVous pouvez utiliser le service `rest` directement depuis le client Mineral ou en rÃ©cupÃ©rant le service `Datastore` depuis l'`IoC`.\n\n:::code-group labels=[main.dart, function.dart]\n\n```dart\nFuture\u003Cvoid> main() async {\n  final client = ClientBuilder()\n    .setCache(MemoryProvider.new)\n    .build();\n\n  final serverId = '583050048766476353';\n  final channels = await client.rest.channel.fetch(serverId); // [!code highlight]\n\n  print(channels); // Map\u003CSnowflake, Channel>\n\n  await client.init();\n}\n```\n\n```dart\nFuture\u003Cvoid> fn() async {\n  final datastore = ioc.resolve\u003CDataStoreContract>();\n\n  final serverId = '583050048766476353';\n  final channels = await datastore.channel.fetch(serverId);\n\n  print(channels); // Map\u003CSnowflake, Channel>\n}\n```\n\n:::","src/content/docs/concepts/datastore.mdx","aba7ac8d3c2d9c00","immutability",{"id":213,"data":215,"body":219,"filePath":220,"digest":221,"deferredRender":21},{"title":216,"description":217,"permalink":213,"order":35,"icon":218},"Immutability","Immutability is a concept that ensures the data is not modified after it is created.","lucide:lock","# Immutability\n\nImmutability is a core concept in functional programming and software development that ensures the state of an object\ncannot be modified after it is created. This principle helps in creating predictable and maintainable code by avoiding\nside effects and ensuring that data remains consistent throughout the application lifecycle.\n\n---\n\n## Benefits\n\n- **Predictability**: Immutable objects provide a predictable state, making it easier to reason about the code.\n- **Debugging**: Debugging becomes simpler as the state of an object does not change unexpectedly.\n- **Cacheability**: Immutable objects can be safely cached and reused without the risk of modification.\n\n---\n\n## Impact on the code\n\nIn Mineral, data objects are immutable by default.\nThis means that once an object is created, its state cannot be changed.\n\n> [!note]\n> If you need to compare an old object with a new one, you should get a new object from the API.\n\nIt is important to note that every event received by Discord events is made immutable by default.\nThis means that when you try to perform an asynchronous action to Discord's HTTP API, the object used as the access\npoint to the method will not be altered despite the success of the operation.\n\n:::code-group labels=[main.dart]\n```dart\nFuture\u003Cvoid> main(_, port) async {\n  final client = ClientBuilder()\n    .setHmrDevPort(port)\n    .build();\n\n  client.events.server.serverCreate((server) async {\n    await server.setName('New Server');\n    \n    // Server name is still the same\n    assert(server.name != 'New Server');\n  });\n\n  await client.init();\n}\n```\n:::","src/content/docs/concepts/immutability.mdx","b5684a9d83fecf09","examples",["Map",224,225],"ping-pong",{"id":224,"data":226,"body":230,"filePath":231,"digest":232,"deferredRender":21},{"title":227,"description":228,"permalink":224,"order":35,"icon":229},"Ping Pong","Ping Pong is a simple example that shows how to use the framework.","lucide:ping-pong","# Ping Pong","src/content/docs/examples/ping-pong.mdx","5a2393e4b8593b82"]